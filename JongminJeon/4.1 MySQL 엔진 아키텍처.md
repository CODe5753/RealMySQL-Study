
# 4. 아키텍처

## 4.1. MySQL 엔진 아키텍처

### 4.1.1. MySQL의 전체 구조

![alt](./src/img/4.1%20MySQL%20서버의%20전체%20구조.png)

- 3개 레이어
- MySQL 엔진 (MyISAM: 마이아이삼이라고 읽는다고 한다.)
- 스토리지 엔진
- 운영체제, 하드웨어

#### 4.1.1.1. MySQL 엔진

- 커넥션 핸들러, SQL 파서, 전처리기, 옵티마이저
- 캐시 & 버퍼도 가지고 있음

#### 4.1.1.2. 스토리지 엔진

- 디스크에 데이터를 저장하거나 읽어오는 부분 CRUD
- Cache: MyISAM Key Cache, InnoDB 버퍼 풀

#### 4.1.1.3. 핸들러 API

- MySQL엔진 -> 핸들러 -> 스토리지 엔진
- 사람 -> 핸들 -> 자동차
`show globl status like 'Handler%'`

### 4.1.2. MySQL 스레딩 구조

![alt](./src/img/4.2%20MySQL의%20스레딩%20모델.png)

- Process (X)
- Thread (O)
  - Foreground: Foregound Thread, Connection = 1:1
  - Background
- MySQL CE (Community Edition)
- MySQL Enterprise Edition & Percona MySQL
  - Thread Pool 지원
  - Foreground Thread, Connection = 1:N

#### 4.1.2.1. 포그라운드 스레드(클라이언트 스레드)

- 1. 데이터를 MySQL 데이터 버퍼나 캐시로부터 가져온다.
- 2. 버퍼나 캐시에 데이터가 없는 경우에 디스크 또는 인덱스 파일로부터 데이터를 가져와 처리한다.
버퍼, 캐시, 디스크 파일, 인덱스 파일은 어떤 레이어에 있는가?
  - 버퍼: MySQL 엔진(메모리), 스토리지 엔진(메모리?)
  - 캐시: MySQL 엔진(메모리)
  - 인덱스 파일: 운영 체제(디스크: 하드웨어)
  - 디스크 파일: 운영 체제(디스크: 하드웨어)

#### 4.1.2.2. 백그라운드 스레드

- InnoDB 엔진에 해당사항이 많다.
스레드 종류 (쓰기 역할을 하는 스레드들이 중요)
- Insert Buffer 병합
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 **스레드**
- 잠금이나 데드락을 모니터링하는 스레드

버퍼와 캐시의 차이?
- 캐시: 읽기
- 버퍼: 쓰기
- https://rainbound.tistory.com/m/entry/buffer-cache-%EC%B0%A8%EC%9D%B4#:~:text=%EC%BA%90%EC%8B%9C(Cache)%EB%8A%94%20%EC%96%B4%EB%96%A4%20%EC%9E%91%EC%97%85,%EC%93%B0%EA%B8%B0%EB%B6%80%EB%B6%84%EC%97%90%20%EC%82%AC%EC%9A%A9%EB%90%9C%EB%8B%A4.
- https://hpotter1993.tistory.com/15
- https://simplicable.com/IT/cache-vs-buffer
- https://ryusstory.tistory.com/entry/Cache-Buffer-%EC%BA%90%EC%89%AC%EC%99%80-%EB%B2%84%ED%8D%BC

### 4.1.3. 메모리 할당 및 사용 구조

![alt](./src/img/4.3%20MySQL의%20메모리%20사용%20및%20할당%20구조.png)

- 글로벌, 세션(커넥션) 메모리 영역

#### 4.1.3.1. 글로벌 메모리 영역

- 클라이언트 <-> 서버 간의 커넥션 (세션)에서의 메모리 영역
- 소트 버퍼, 조인 버퍼, 커넥션 버퍼, 결과 버퍼
  - 소트, 조인버퍼: 쿼리를 실행하는 순간에만 할당했다가 해제
  - 커넥션 버퍼, 결과 버퍼: 커넥션이 열려있는 동안 계속 할당

- 각 작업이 MySQL 엔진 + 스토리지 엔진 어디에서 실행되는지 알아야 한다.

### 4.1.4. 플러그인 스토리지 엔진 모델

![alt](./src/img/4.4%20MySQL%20플러그인%20모델.png)

- 플러그인 모델로 스토리지 엔진외에도 특별한 기능을 제공하는 모듈들을 플러그인해서 사용할 수 있음
- 전문 검색 검색어 파서, 사용자 인증 모듈
- 모듈 별 독립적인 기능
![alt](./src/img/4.5%20MySQL%20엔진과%20스토리지%20엔진의%20처리%20영역.png)

핸들러: MySQL 소스코드에서 유래한 용어로 사용자 인터페이스를 의미

- MySQL엔진 -> 핸들러 -> 스토리지 엔진
- 사람 -> 핸들 -> 자동차

### 4.1.5. 컴포넌트

- MySQL 8.0 부터는 플러그인이 아니고 컴포넌트로 제공한다
플러그인 vs. 컴포넌트
- 컴포넌트: 컴포넌트 간의 상호작용을 제공한다.

### 4.1.6. 쿼리 실행 구조

![alt](./src/img/4.6%20쿼리%20실행%20구조.png)

#### 4.1.6.1. 쿼리 파서

- 문법 오류 체크 후 파서 트리를 생성

#### 4.1.6.2. 전처리기

- 파서 트리의 컬럼이름, 내장 함수 등 각 객체의 유무와 권한 확인

#### 4.1.6.3. 옵티마이저

- 쿼리 실행 계획 생성 (앞으로 많이 다루게 된다고 합니다)

#### 4.1.6.4. 실행 엔진

- 옵티마이저 -> 실행 엔진 -> 핸들러

#### 4.1.6.5. 핸들러(스토리지 엔진)

- 위 1 ~ 4는 MySQL 엔진, 핸들러는 중간에 있긴 하지만 스토리지 엔진으로 본다.

### 4.1.7. 복제 (16장에서 깊게)

### 4.1.8. 쿼리 캐시

- 동일 SQL 쿼리가 발생하면 결과를 바로 리턴
- 하지만 원본 테이블에서 결과와 관련있는 데이터가 변경되면 캐시를 삭제 해야 했고, 이는 동시 처리 성능 저하를 유발 했음
- MySQL 8.0 으로 오면서 쿼리 캐시가 완전히 제거되었음
- 서버의 쿼리 캐시 기능은 데이터 변경은 없고 읽기만 하는 서비스에는 매우 훌륭한 기능이지만 이런 요건을 가진 서비스는 거의 없음

### 4.1.9. 스레드 풀

- 목적
- 부작용
- 동작 원리
  - 스레드 풀의 다른 스레드가 작업을 끝낼때까지 기다리거나
  - 스레드 풀에 새로운 작업 스레드를 추가 (thread_pool_max_threads 시스템 변수로 제한)
  - thread_poll_stall_limit = 0 이면 스레드풀이 스케일 아웃되는 일이 없음
- 그림 4.7 ~ 4.8 해석

### 4.1.10. 트랜잭션 지원 메타데이터
- 기존에는 파일에 정보를 저장

어디에서 최적화할 수 있을까?