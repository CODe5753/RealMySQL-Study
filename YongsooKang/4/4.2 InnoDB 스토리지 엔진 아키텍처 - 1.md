[InnoDB 스토리지 엔진의 특징](#innodb-스토리지-엔진의-특징)

- [4.2.1 Primary key에 의한 클러스터링](#421-primary-key에-의한-클러스터링)
- [4.2.2 외래 키 지원](#422-외래-키-지원)
- [4.2.3 MVCC (Multi Version Concurrency Control)](#423-mvcc-multi-version-concurrency-control)
- [4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)](#424-잠금-없는-일관된-읽기-non-locking-consistent-read)
- [4.2.5 자동 데드락 감지](#425-자동-데드락-감지)
- [4.2.6 자동화된 장애 복구](#426-자동화된-장애-복구)

[4.2.7 InnoDB 버퍼 풀](#427-innodb-버퍼-풀)
- [4.2.7.1 버퍼 풀의 크기 설정](#4271-버퍼-풀의-크기-설정)
- [4.2.7.2 버퍼 풀의 구조](#4272-버퍼-풀의-구조)
    - [LRU list](#lru-list)
    - [Flush list](#flush-list)
    - [Free list](#free-list)
- [4.2.7.3 버퍼 풀과 리두 로그](#4273-버퍼-풀과-리두-로그)
- [4.2.7.4 버퍼 풀 플러시 (Buffer Pool Flush)](#4274-버퍼-풀-플러시-buffer-pool-flush)
    - [4.2.7.4.1 플러시 리스트 플러시](#42741-플러시-리스트-플러시)
    - [4.2.7.4.2 LRU 리스트 플러시](#42742-lru-리스트-플러시)
- [4.2.7.5 버퍼 풀 상태 백업 및 복구](#4275-버퍼-풀-상태-백업-및-복구)
- [4.2.7.6 버퍼 풀의 적재 내용 확인](#4276-버퍼-풀의-적재-내용-확인)

[Q&A](#qa)

# InnoDB 스토리지 엔진의 특징
![img](./img/4.9%20InnoDB%20%EA%B5%AC%EC%A1%B0.png)
## 4.2.1 Primary key에 의한 클러스터링
> InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다.
- 프라이머리 키 값 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
- 쿼리의 실행 계획에서 Primary key는 다른 보조 인덱스에 비해 비중이 높게 설정된다.
- InnoDB는 클러스터링 키를 지원한다.
- MyISAM에서는 클러스터링 키를 지원하지 않아서 Primary Key, 세컨더리 인덱스의 구조적 차이가 없다.

## 4.2.2 외래 키 지원
- InnoDB 스토리지 엔진 레벨에서 지원하고, MyISAM, MEMORY 테이블에서는 사용할 수 없다.
- InnoDB에서 부모, 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하다.
    - 변경 시에는 반드시 부모, 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하다.
    - 따라서 잠금이 여러 테이블로 전파되어 데드락이 발생할 때가 많아서 주의해야 한다.
- 수동으로 데이터 조작 시 작업이 실패할 수 있다.
    - `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래키 관계에 대한 체크를 일시적으로 멈출 수 있다.
        - 이렇게 되면 대략 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요 없어서 빠르게 처리할 수 있다.
        - 해당 상태에서는 부모 테이블에 대한 작업 (ON DELETE/UPDATE CASCADE 옵션)을 무시한다.
        - ex) `SET foreign_key_checks=OFF`

## 4.2.3 MVCC (Multi Version Concurrency Control)
> 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능으로 잠금을 사용하지 않는 일관된 읽기를 제공한다.
- InnoDB는 언두 로그로 이 기능을 구현한다.
- Multi Version: 하나의 레코드에 의해 여러 개의 버전이 동시에 관리된다는 의미

```sql
CREATE TABLE member (
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(100) NOT NULL,
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');

COMMIT;
```
![img](./img/4.10%20InnoDB%EC%9D%98%20%EB%B2%84%ED%8D%BC%20%ED%92%80%EA%B3%BC%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%8C%8C%EC%9D%BC%EC%9D%98%20%EC%83%81%ED%83%9C.png)
- member 테이블을 생성하여 데이터를 `insert` 할 시 InnoDB 버퍼 풀에 데이터가 저장된다.
- `commit` 과정을 거친 후에 디스크에 데이터가 저장된다.

```sql
UPDATE member SET m_area='경기' WHERE m_id=12;
```
![img](./img/4.11%20UPDATE%20%ED%9B%84%20InnoDB%20%EB%B2%84%ED%8D%BC%20%ED%92%80%EA%B3%BC%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%8C%8C%EC%9D%BC%20%EB%B0%8F%20%EC%96%B8%EB%91%90%20%EC%98%81%EC%97%AD%EC%9D%98%20%EB%B3%80%ED%99%94.png)
- `update` 시 먼저 InnoDB 버퍼 풀의 변경될 가능성이 있는 데이터가 언두 로그에 복사된다.
- 이후 InnoDB 버퍼 풀의 데이터가 바로 변경된다.
- 만약 `commit` 단계가 진행되지 않은 상태로 `select`로 데이터를 조회한다면
    - 격리 수준이 `READ_UNCOMMITTED`인 경우에는 InnoDB가 갖고있는 데이터를 조회한다.
    - 격리 수준이 `READ_COMMITTED`이거나 그 이상(`REPEATABLE_READ`, `SERIALIZABLE`)인 경우 언두 영역의 데이터를 반환한다.
    - 이러한 과정을 MVCC라고 함
        - 하나의 데이터에 대해 2가지 버전이 유지되고, 필요에 따라 보여질 데이터가 결정되는 구조
        - 언두 로그의 데이터가 많아져 언두 영역이 저장되는 시스템 테이블스페이스의 공간이 많이 늘어나는 상황이 발생할 수 있다.
- `commit` 명령을 실행하면 InnoDB의 데이터가 영구적인 데이터가 된다.
    - commit 시 언두 영역의 데이터가 바로 삭제되지는 않으며, 더 이상 해당 언두 영역을 필요로하는 트랜잭션이 없을 때 삭제된다.
- `rollback` 시 언두 영역에 있는 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 데이터를 모두 삭제한다.

## 4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
> InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 잠금을 걸지 않으므로 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.
- 격리 수준 READ_COMMITTED 이상일 때 순수 SELECT 작업은 다른 트랜잭션 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.
    - 변경 전의 데이터를 읽기 위해 언두 로그를 사용한다.
- 다만 이러한 작업을 위해 언두 로그를 삭제하지 못하고 유지해야하므로 MySQL 서버가 느려지거나 문제가 발생할 때가 있다.
    - 트랜잭션이 시작됐다면 가능한 한 빨리 rollback or commit으로 트랜잭션을 완료하는 것이 좋다.

## 4.2.5 자동 데드락 감지
> InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료한다.
    - 종료할 트랜잭션을 판단하는 기준은 트랜잭션의 언두 로그 양이다.
    - 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 rollback의 대상이 된다.
        - 언두 처리할 내용이 적고, 강제 롤백으로 인한 MySQL 서버 부하도 덜 유발하기 때문
- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 볼 수가 없어서 데드락 감지가 불확실할 수 있다.
    - `innodb_table_locks` 시스템 변수를 활성화하여 InnoDB 스토리지 엔진 내부의 레코드 뿐만 아니라 테이블 레벨의 잠금도 감지할 수 있게 된다.
- 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 갯수가 많아지면 데드락 감지 스레드가 느려진다.
    - 데드락 감지 스레드는 잠금 목록이 저장된 리스트에 잠금을 걸고 데드락 스레드를 찾는다.
    - 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미친다.
    - 더 많은 CPU 자원을 소모하게 된다.
    - MySQL 서버에서 제공하는 `innodb_deadlock_detect` 시스템 변수를 `OFF`로 설정하면 데드락 감지 스레드는 작동하지 않게 된다.
        - 데드락 발생 시 무한정 대기 상태가 된다.
        - `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환한다.

## 4.2.6 자동화된 장애 복구
- InnoDB에 손실이나 장애로부터 데이터를 보호하기 위한 메커니즘이 탑재되어있다.
- 이를 이용하여 MySQL 서버가 시작될 때 복구 작업이 자동으로 진행된다.
- 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고, MySQL 서버는 종료된다.

-> MySQL 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 시작하도록 한다.
- InnoDB의 로그 파일이 손상됐다면 6으로 설정하고 MySQL 서버를 기동한다.
- InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 MySQL 서버를 기동한다.
- 어떤 부분이 문제인지 알 수 없다면 1 ~ 6 범위 내에서 변경하면서 MySQL 서버를 재시작해본다.
- 값이 커질수록 심각한 상황이므로 데이터 손실 가능성은 커지고, 복구 가능성은 작아진다.

### innodb_force_recovery
- MySQL 서버가 기동되고 InnoDB 테이블이 인식된다면 mysqldump를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.
- `innodb_force_recovery` 값이 0이 아닌 복구모드에서는 SELECT 이외의 쿼리는 수행할 수 없다.
1. SRV_FORCE_IGNORE_CORRUPT
    - InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 MySQL 서버를 시작한다.
    - `Database page corruption on disk or a failed` 메시지가 출력될 때 대부분 해당
    - mysqldump를 이용해 데이터베이스를 다시 구축하는 것이 좋다.
2. SRV_FORCE_NO_BACKGROUND
    - 백그라운드 스레드 중 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다.
    - 트랜잭션이 commit되어 불필요해진 언두 데이터는 InnoDB의 메인 스레드에 의해 주기적으로 삭제된다.
    - InnoDB의 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생할 때 사용한다.
3. SRV_FORCE_NO_TRX_UNDO
    - MySQL 서버 시작 시 커밋되지 않은 트랜잭션의 작업을 rollback하지 않고 그대로 둔다.
    - MySQL 서버가 시작되면 mysqldump를 이용해 데이터를 백업해서 다시 데이터베이스를 구축하는 것이 좋다.
4. SRV_FORCE_NO_IBUF_MERGE
    - MySQL 서버 재시작 시 인서트 버퍼의 손상을 감지하면 InnoDB는 에러를 발생시키고, MySQL 서버는 시작하지 못한다.
    - InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL이 시작되게 한다.
    - 인서트 버퍼는 실제 데이터가 아닌 인덱스에 관련된 부분이므로 테이블을 덤프하고 데이터베이스를 다시 구축하면 데이터의 손실 없이 복구할 수 있다.
5. SRV_FORCE_NO_UNDO_LOG_SCAN
    - InnoDB 엔진이 언두 로그를 무시하고 MySQL을 시작하도록 한다.
    - MySQL 서버가 종료되던 시점에 commit되지 않았던 작업도 모두 commit된 것처럼 처리되므로 실제로 잘못된 데이터가 남을 수도 있다.
    - mysqldump를 이용해 데이터를 백업하고 데이터베이스를 새로 구축해야 한다.
6. SRV_FORCE_NO_LOG_REDO
    - 리두 로그를 모두 무시한 채로 MySQL 서버가 시작된다.
    - commit이 되었다고 해도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이터는 무시된다.
    - 기존 InnoDB의 리두 로그는 모두 삭제하거나 별도의 디렉토리에 백업하고 MySQL 서버를 시작하는 것이 좋다.
    - mysqldump를 이용해 데이터를 백업하고 데이터베이스를 새로 구축하는 것이 좋다.
    
-> 모두 실패 시 백업을 이용하여 데이터베이스를 다시 구축하도록 한다.

# 4.2.7 InnoDB 버퍼 풀
> 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 한다.
- INSERT, UPDATE, DELETE와 같은 데이터 변경 쿼리로 인한 랜덤한 디스크 작업 횟수를 줄인다.

## 4.2.7.1 버퍼 풀의 크기 설정
> 운영체제와 각 클라이언트 스레드가 사용할 메모리를 충분히 고려해서 설정한다.
- MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만 레코드 버퍼가 상당한 메모리를 사용하기도 한다.
    - 레코드 버퍼: 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간
    - 커넥션이 많고 사용하는 테이블도 많다면 버퍼 용도로 사용되는 메모리 공간이 많을 수 있다.
    - MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정할 수 없다.
    - 전체 커넥션 갯수와 각 커넥션에서 읽고 쓰는 테이블의 갯수에 따라 결정된다.
    - 동적으로 해제되기도 하므로 정확히 필요한 메모리 공간의 크기를 계산할 수 없다.
- MySQL 5.7버전부터 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 되었다.
    - `innodb_buffer_pool_size` 시스템 변수로 크기 설정
    - 크리티컬한 변경이므로 MySQL 사용이 상대적으로 적을 때 변경하는 것이 좋다.
    - 처음에 적절하게 설정하고, 조금씩 증가시키는 것이 최적의 방법이다.
        - 나머지는 다른 프로그램이 사용할 수 있는 공간으로 확보한다.
    - 버퍼 풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크므로 되도록 하지 않는 것이 좋다.
- InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금으로 인해 내부 잠금 경합을 많이 유발해왔다.
    - 버퍼 풀을 여러개로 분리해서 관리할 수 있게 개선되었다.
    - `innodb_buffer_pool_instances` 시스템 변수를 이용해서 분리
    - 각 버퍼 풀을 버퍼 풀 인스턴스라고 한다.

## 4.2.7.2 버퍼 풀의 구조
- InnoDB 스토리지 엔진은 버퍼 풀을 페이지 크기의 조각으로 쪼개어 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.
- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 LRU, Flush, Free list라는 3개의 자료구조를 관리한다.

### LRU list
![img](./img//4.13%20%EB%B2%84%ED%8D%BC%20%ED%92%80%20%EA%B4%80%EB%A6%AC%EB%A5%BC%20%EC%9C%84%ED%95%9C%20LRU%20%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EA%B5%AC%EC%A1%B0.png)
> LRU와 MRU 리스트가 결합된 형태
- Old 서브리스트 영역이 LRU에 해당된다.
- New 서브리스트 영역이 MRU에 해당된다.
- 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이 목적
1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
    - InnoDB 어댑티브 해시 인덱스를 이용해 페이지 검색
    - 해당 테이블의 인덱스를 이용해 버퍼 풀에서 페이지 검색
    - 이미 데이터 페이지가 있다면 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더에 추가
3. LRU 헤더에 적재된 데이터 페이지가 읽히면 MRU 헤더로 이동
4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 오랫동안 사용되지 않으면 aging 상태가 되어 버퍼 풀에서 제거된다.
    - 해당 데이터 페이지가 사용된다면 새로운 나이를 부여하고, MRU 헤더로 이동한다.
5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

### Flush list
> 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리한다.
- 디스크에서 읽은 상태에서 한 번 이상의 변경이 있을 때 Flush list에 추가되고, 특정 시점이 되면 디스크로 기록돼야 한다.
- 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
    - 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다.
- 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 보장하지 않는다.
    - InnoDB 스토리지 엔진은 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화 한다.
    - 체크포인트는 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할을 한다.

### Free list
> InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어있는 페이지들의 목록
- 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.

## 4.2.7.3 버퍼 풀과 리두 로그
- InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정할수록 쿼리의 성능이 빨라진다.
    - 이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 버퍼 풀 공간이 되었을 때가 최대 성능

![img](./img/4.14%20InnoDB%20%EB%B2%84%ED%8D%BC%20%ED%92%80%EA%B3%BC%20%EB%A6%AC%EB%91%90%20%EB%A1%9C%EA%B7%B8%EC%9D%98%20%EA%B4%80%EA%B3%84.png)
- InnoDB의 버퍼 풀에는 디스크에서 읽은 상태로 변경되지 않은 `클린 페이지`와 INSERT, UPDATE, DELETE 명령에 의해 변경된 데이터를 가진 `더티 페이지`가 있다.
    - 더티 페이지는 디스크와 버퍼 풀의 데이터가 다르므로 디스크로 기록되어야 한다.
    - 더티 페이지는 버퍼 풀에 무한정 머무를 수 있는 것은 아니다.
    - 데이터 변경이 계속 발생하면 리두 로그 파일에 기록된 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다.
    - 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야 한다.
        재사용 불가능한 공간을 활성 리두 로그라고 한다.
- LSN (Log Sequence Number): 리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가된 값을 갖는다.
    - InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.
    - 이렇게 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다.
    - 활성 리두 로그 공간의 마지막은 계속해서 증가하므로 체크포인트와 무관하다.
    - 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 체크포인트 에이지(age)라고 한다.
- 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고, 체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다.
    - 체크포인트 LSN보다 작은 LSN 값을 가진 리두 로그 엔트리도 포함
    1. InnoDB 버퍼 풀은 100GB이며 리두 로그 파일의 전체 크기는 100MB인 경우
        - 버퍼 풀의 크기는 매우 크지만 실제 쓰기 버퍼링을 위한 효과는 거의 못 본다.
        - 리두 로그 파일의 크기가 100MB이므로 체크포인트 에이지도 최대 100MB만 허용한다.
        - 평균 리두 로그 엔트리가 4KB라면 25600개 정도의 더티 페이지만 버퍼 풀에 보관할 수 있게 된다.
    2. InnoDB 버퍼 풀은 100MB이며 리두 로그 파일의 전체 크기는 100GB인 경우
        - 버퍼 풀의 크기가 100MB이기 때문에 최대 허용 가능한 더티 페이지는 100MB가 된다.
        - 리두 로그 파일이 크기 때문에 급작스러운 디스크 쓰기가 발생할 가능성이 높다.

## 4.2.7.4 버퍼 풀 플러시 (Buffer Pool Flush)
- ~ MySQL 5.6
    - 급작스럽게 디스크 기록이 폭증해서 MySQL 서버의 사용자 쿼리 처리 성능에 영향을 받는 경우가 많았다.
- MySQL 8.0 ~
    - 대부분 서비스에서 더티 페이지를 디스크에 동기화하는 부분에서 디스크 쓰기 폭증 현상은 발생하지 않았다.
- 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행한다.

### 4.2.7.4.1 플러시 리스트 플러시
> 플러시 리스트(Flush list)에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다.
- 오래된 리두 공간을 지우기위해 InnoDB 버퍼 풀의 더티 페이지를 디스크로 동기화한다.
- 언제부터 얼마나 많은 더티 페이지를 한 번에 디스크로 기록하느냐에 따라 사용자의 쿼리 처리가 악영향을 받지 않으면서 부드럽게 처리된다.
- 시스템 변수
    - `innodb_page_cleaners`
        - 클리너 스레드의 갯수를 조정
            - 클리너 스레드: 더티 페이지를 디스크로 동기화하는 스레드
        - InnoDB 스토리지 엔진은 여러 개의 InnoDB 버퍼 풀 인스턴스를 동시에 사용할 수 있다.
            - `innodb_page_cleaners` 설정 값이 버퍼 풀 인스턴수 갯수보다 많으면 `innodb_buffer_pool_instances` 설정 값으로 자동으로 변경한다.
                - 하나의 클리너 스레드가 하나의 버퍼 풀 인스턴스를 처리하도록 맞춰준다.
            - `innodb_page_cleaners` 설정 값이 버퍼 풀 인스턴스 갯수보다 적으면 하나의 클리너 스레드가 여러 개의 버퍼 풀 인스턴스를 처리한다.
            - 따라서 `innodb_page_cleaners == innodb_buffer_pool_instances`가 되도록 설정한다.
    - `innodb_max_dirty_pages_pct`
        - 버퍼 풀에서 가질 수 있는 더티 페이지의 비율 (되도록 기본값을 유지)
        - 일반적으로는 더티 페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링함으로써 여러 번의 디스크 쓰기를 한 번으로 줄이는 효과를 극대화할 수 있다.
    - `innodb_max_dirty_pages_pct_lwm`
        - 조금씩 더티 페이지를 디스크로 기록하게 하는 최소 더티 페이지 비율
        - 기본 값이 10% 수준인데 조금 더 높은 값으로 조정하여 디스크 쓰기 횟수를 줄일 수 있다.
        - 더티 페이지가 많을수록 디스크 쓰기 폭발 (Disk IO Burst) 현상이 발생할 가능성이 높아진다.
    - `innodb_io_capacity`
        - 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준의 값
    - `innodb_io_capacity_max`
        - 디스크가 최대의 성능을 발휘할 때 어느 정도의 디스크 읽고 쓰기가 가능한지 (더티 페이지 쓰기)
    - `innodb_flush_neighbors`
        - 더티 페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중 더티 페이지가 있다면 InnoDB 스토리지 엔진이 함께 묶어서 디스크로 기록하게 해주는 기능 활성화 여부
        - 데이터 저장에 HDD를 사용한다면 값을 1 or 2로 설정해서 활성화하는 것이 좋다.
        - 데이터 저장에 SDD를 사용한다면 비활성화하는 것이 좋다.
    - `innodb_adaptive_flushing`
        - 어댑티브 플러시 기능 활성화 여부 (기본 값은 활성화 상태)
    - `innodb_adaptive_flushing_lwm`
        - 어댑티브 플러시 알고리즘이 작동하게 하는 활성 리두 로그의 공간 비율

### 4.2.7.4.2 LRU 리스트 플러시
> LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만든다.
- LRU 리스트의 끝부분부터 시작해서 최대 `innodb_lru_scan_depth` 시스템 변수에 설정된 갯수만큼의 페이지를 스캔한다.
- 스캔하면서 더티 페이지는 디스크에 동기화하게 하며, 클린 페이지는 즉시 Free 리스트로 페이지를 옮긴다.

## 4.2.7.5 버퍼 풀 상태 백업 및 복구
- 쿼리 요청이 매우 빈번한 서버를 셧다운했다가 다시 시작하면 쿼리 처리 성능이 1/10도 안되는 경우가 대부분이다.
    - 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비돼 있으므로 디스크에서 데이터를 읽지 않아도 쿼리가 처리될 수 있기 때문이다.
    - 버퍼 풀이 워밍업 되어있는 상태가 그렇지 않은 상태보다 쿼리 처리속도가 훨씬 빠르다.
        - 디스크의 데이터가 버퍼 풀에 적재되어 있는 상태를 워밍업이라고 표현한다.
    - MySQL 5.5에서는 서버를 다시 시작하기 전에 강제 워밍업을 위해 주요 테이블과 인덱스 대상으로 풀 스캔을 하고 서비스를 오픈했었다.
    - MySQL 5.6부터는 버퍼 풀 덤프 및 적재 기능이 도입되었다.
        - 서버를 재시작하는 경우 서버를 셧다운하기 전에 `innodb_buffer_pool_dump_now` 시스템 변수를 이용해 현재 InnoDB 버퍼 풀의 상태를 백업할 수 있다.
            - `SET GLOBAL innodb_buffer_pool_dump_now=ON;`
        - 서버 다시 시작 시 `innodb_buffer_pool_load_now` 시스템 변수를 이용해 백업된 버퍼 풀의 상태를 다시 복구할 수 있다.
            - `SET GLOBAL innodb_buffer_pool_load_now=ON;`
            - 버퍼 풀의 백업은 `ib_buffer_pool` 파일에 기록된다.
            - LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장하기 때문에 용량이 적고, 속도가 매우 빠르다.
            - 다만 백업된 내용을 다시 버퍼 풀로 복구하는 과정은 버퍼 풀의 크기에 따라 상당한 시간이 걸릴 수 있다.
                - 각 테이블의 데이터 페이지를 다시 디스크에서 읽어와야 하는 과정이 필요하기 때문이다.
                - 복구하는 과정의 진행도 확인을 위해 `innodb_buffer_pool_dump_status` 값을 사용한다.
                - 중간에 멈추려고 한다면 `innodb_buffer_pool_load_abort` 시스템 변수를 사용한다.
            - 버퍼 풀의 백업과 복구를 자동화하려면 `innodb_buffer_pool_dump_at_shutdown`, `innodb_buffer_pool_load_at_startup` 설정을 MySQL 서버의 설정 파일에 넣어두면 된다.

## 4.2.7.6 버퍼 풀의 적재 내용 확인
- MySQL 5.6 ~ MySQL 8.0
    - MySQL 서버의 `information_schema` 데이터베이스의 `innodb_buffer_page` 테이블을 이용해 InnoDB 버퍼 풀의 메모리에 어떤 테이블들이 적재되어 있는지 확인할 수 있었다.
    - 버퍼 풀이 큰 경우에는 테이블 조회가 상당히 큰 부하를 일으키면서 서비스 쿼리가 많이 느려지는 문제가 있었다.
    - 실제 서비스용으로 사용되는 MySQL 서버에서는 버퍼 풀의 상태를 확인하는 것이 거의 불가능했다.
- MySQL 8.0 ~
    - `information_schema` 데이터베이스에 `innodb_cached_indexes` 테이블이 추가되었다.
    - 이 테이블을 이용하여 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재되어 있는지 확인할 수 있다.

# Q&A
- InnoDB 버퍼 풀에서 디스크로 데이터가 저장되는 시점?
- commit vs checkpoint
