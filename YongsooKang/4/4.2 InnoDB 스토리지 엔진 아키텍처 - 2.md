[4.2.8 Double Write Buffer](#428-double-write-buffer)

[4.2.9 언두 로그](#429-언두-로그)
- [4.2.9.1 언두 로그 모니터링](#4291-언두-로그-모니터링)
- [4.2.9.2 언두 테이블스페이스 관리](#4292-언두-테이블스페이스-관리)

[4.2.10 체인지 버퍼](#4210-체인지-버퍼)

[4.2.11 리두 로그 및 로그 버퍼](#4211-리두-로그-및-로그-버퍼)
- [MySQL 서버의 비정상 종료](#mysql-서버의-비정상-종료)
    - [ACID](#acid)
- [4.2.11.1 리두 로그 아카이빙](#42111-리두-로그-아카이빙)
- [4.2.11.2 리두 로그 활성화 및 비활성화](#42112-리두-로그-활성화-및-비활성화)

[4.2.12 어댑티브 해시 인덱스](#4212-어댑티브-해시-인덱스)
- [해시 인덱스](#해시-인덱스)
- [성능 향상에 도움이 되지 않는 경우](#성능-향상에-도움이-되지-않는-경우)
- [성능 향상에 도움이 되는 경우](#성능-향상에-도움이-되는-경우)

[4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교](#4213-innodb와-myisam-memory-스토리지-엔진-비교)

[Q&A](#qa)

# 4.2.8 Double Write Buffer
- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다.
    - 이로 인해 InnoDB의 스토리지 엔진에서 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있다.
    - 페이지가 일부만 기록되는 현상을 파셜 페이지 or 톤 페이지라고 한다.
    - 하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있다.

![img](./img/4.15%20Double%20Write%20%EC%9E%91%EB%8F%99%20%EB%B0%A9%EC%8B%9D.png)
- DoubleWrite 버퍼에 기록된 변경 내용은 실제 데이터 파일에 `A` ~ `E` 더티 페이지가 정상적으로 기록되면 필요 없어진다.
- DoubleWrite 버퍼의 내용은 실제 데이터 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다.
    - InnoDB가 재시작되면 DoubleWrite 버퍼와 데이터 파일의 페이지들을 모두 비교한다.
    - 다른 내용이 있다면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다.
    - `innodb_doublewrite` 시스템 변수로 해당기능 사용여부를 결정한다.
- DoubleWrite 버퍼는 데이터의 안정성을 위해 자주 사용된다.
    - 데이터 무결성이 중요한 서비스에서는 활성화하는 것이 좋다.
    - 데이터베이스 서버의 성능을 위해 InnoDB 리두 로그 동기화 설정을 1이 아닌 값으로 설정했다면 DoubleWrite도 비활성화하는 것이 좋다.

# 4.2.9 언두 로그
> INSERT, UPDATE, DELETE로 변경되기 이전에 별도로 백업된 데이터
- 트랜잭션 보장
    - 트랜잭션이 rollback되면 트랜잭션 도중 변경된 데이터를 언두 로그를 이용하여 변경 전 데이터로 복구한다.
- 격리 수준 소장
    - 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽는다.

## 4.2.9.1 언두 로그 모니터링
`UPDATE member SET name = '홍길동' WHERE member_id=1;`
- 트랜잭션을 commit하지 않아도 실제 데이터 파일 내용은 변경된다.
- 언두 영역에는 변경되기 전의 데이터가 백업된다.
- commit하면 현재 상태가 유지되고, rollback하면 언두 영역의 데이터로 다시 복구한다.
- 언두 로그의 데이터의 용도
    - 트랜잭션 rollback 대비
    - 트랜잭션 격리 수준을 유지하면서 높은 동시성을 제공한다.
        - 데이터를 변경/조회 시 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지 결정
- ~ MySQL 5.5
    - 한 번 증가한 언두 로그 공간은 MySQL 서버를 새로 구축하지 않는 한 다시 줄어들지 않는다.
- MySQL 8.0 ~
    - 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것이 가능하다.
    - MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여주기도 한다.
- 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않으므로 언두 로그가 얼마나 증가했는지 모니터링하여 언두 로그 건수를 확인하도록 한다.
    - `SHOW ENGINE INNODB STATUS \G`
    - ```sql
        # MySQL 8.0
        SELECT count
        FROM information_schema.innodb_metrics
        WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
## 4.2.9.2 언두 테이블스페이스 관리
> 언두 로그가 저장되는 공간을 언두 테이블스페이스 라고 한다.
- ~ MySQL 5.6
    - 모든 언두 로그가 시스템 테이블스페이스에 저장됐다.
        - 시스템 테이블스페이스의 언두 로그는 서버가 초기화될 때 생성되므로 확장의 한계 존재
        - `innodb_undo_tablespaces` 시스템 변수를 2보다 큰 값으로 설정하면 InnoDB 스토리지 엔진은 더이상 언두 로그를 시스템 테이블 스페이스에 저장하지 않고 별도의 언두 로그 파일을 사용한다.
- MySQL 5.6 ~ 8.0
    - `innodb_undo_tablespaces` 값이 0일 때 언두 로그가 시스템 테이블스페이스에 저장됐다.
- MySQL 8.0.14 ~
    - 위 시스템 변수의 효력은 X
    - 언두 로그는 항상 별도의 로그 파일에 기록되도록 개션되었다.
- ~ MySQL 8.0: 한 번 생성된 언두 로그는 변경이 허용되지 않고 정적으로 사용
- MySQL 8.0 ~: `CREATE UNDO TABLESPACE` `DROP TABLESPACE` 명령어로 언두 테이블 스페이스를 동적으로 추가, 삭제가 가능하다.
- `Undo tablespace truncate`: 언두 테이블스페이스 공간을 필요한 만큼만 남기고 운영체제로 반납하는 것
    > 다음 두가지 모두 MySQL 8.0부터 지원
    - 자동 모드
        - `innodb_undo_log_truncate` 시스템 변수가 `ON`으로 설정된 경우
        - 퍼지 스레드는 주기적으로 언두 로그 파일에서 사용되지 않는 공간을 운영체제로 반납한다.
            - 언두 퍼지라고 한다.
        - `innodb_pruge_rseg_truncate_frequency` 시스템 변수로 작업이 빈번하게 실행되는 정도를 조정한다.
    - 수동 모드
        - `innodb_undo_log_truncate` 시스템 변수가 `OFF`으로 설정된 경우
        - 언두 테이블스페이스를 비활성화하면 퍼지 스레드가 비활성 상태의 언두 테이블스페이스를 찾아서 불필요한 공간을 운영체제로 반납한다.
        - 반납이 완료되면 언두 테이블스페이스를 다시 활성화한다.
        - 수동 모드는 언두 테이블스페이스가 최소 3개 이상은 돼야 작동한다.
        - ```sql
            # 언두 테이블스페이스 비활성화
            ALTER UNDO TABLESPACE tablespace_name SET INACTIVE;
            # 퍼지 스레드에 의해 언두 테이블스페이스 공간이 반납되면 다시 활성화
            ALTER UNDO TABLESPACE tablespace_name SET ACTIVE;

# 4.2.10 체인지 버퍼
> 변경해야 할 인덱스 페이지를 디스크에서 읽어야한다면 즉시 실행하지 않고 저장해두는 공간
- RDBMS에서 데이터 변경 시
    - 해당 테이블에 포함된 인덱스를 업데이트하는 작업이 필요하다.
    - 이 작업은 랜덤하게 디스크를 읽는 작업이 필요하다.
        - 테이블에 인덱스가 많다면 많은 자원을 소모한다.
    - 변경할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행한다.
    - 변경할 인덱스 페이지가 디스크에 있다면 체인지 버퍼에 저장해두고 바로 결과를 반환하여 성능을 향상시킨다.
- 결과를 전달하기 전에 중복 체크가 필요한 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.
- 체인지 버퍼를 임시로 저장된 인덱스 레코드 조각은 이후 체인지 버퍼 머지 스레드에 의해 병합된다.
- ~ MySQL 5.5: INSERT 까지만 버퍼링 가능
- MySQL 8.0 ~: INSERT, UPDATE, DELETE로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링 가능
- 체인지 버퍼는 기본적으로 InnoDB 버퍼 풀로 설정된 메모리의 25%까지 사용할 수 있게 설정되어 있다.
    - 필요 시 50%까지 사용하도록 설정 가능
    - `innodb_change_buffer_max_size` 시스템 변수로 비율을 설정
```sql
-- 체인지 버퍼가 사용 중인 메모리 공간의 크기
SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
FROM performance_schema.memory_summary_global_by_event_name
WHERE EVENT_NAME='memory/innodb/ibuf0ibuf';

-- 체인지 버퍼 관련 오퍼레이션 처리 횟수
SELECT ENGINE INNODB STATUS \G
```

# 4.2.11 리두 로그 및 로그 버퍼
- 리두 로그
    - MySQL 서버가 비정상적으로 종료되었을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않도록 해주는 안전장치다.
    - 트랜잭션의 4가지요소 중 영속성과 밀접하게 연관되어 있다.
- 로그 버퍼
    - 트랜잭션의 변경 내용을 한번에 처리하기 위한 메모리 공간
    - 변경 내용을 디스크에 바로 적용하기보다 한 번에 적용하는 것이 효율적이다.
- MySQL 서버를 포함한 대부분 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다.
- 변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 비용이 필요하다.
    - 데이터베이스 서버는 쓰기 비용이 낮은 자료구조를 가진 리두 로그를 갖고 있으며, 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다.
    - 성능도 중요하므로 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀이나 로그 버퍼와 같은 자료구조도 갖고 있다.
## MySQL 서버의 비정상 종료
1. commit 됐지만 데이터 파일에 기록되지 않은 데이터가 존재할 경우
    - 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하기만 하면 된다.
2. rollback 됐지만 데이터 파일에 이미 기록된 데이터가 존재할 경우
    - 리두 로그로는 해결할 수 없다.
    - 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 데이터 파일에 복사하면 된다.
    - 이 경우에 리두 로그는 변경 사항이 commit/rollback이 되었는지 또는 트랜잭션 실행 중간 상태였는지 확인하는 용도로 사용한다.
- 데이터베이스 서버에서 리두 로그는 트랜잭션이 commit되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다.

### ACID
> 데이터베이스에서 트랜잭션의 무결성을 보장하기 위해 필요한 4가지 요소
- Atomic (원자성): 트랜잭션의 모든 작업은 완벽하게 수행되거나 아예 수행되지 않아야 한다.
- Consistent (일관성): 트랜잭션이 실행되지 전, 후의 상태가 항상 일관된 상태를 유지해야 한다.
- Isolated (격리성): 여러 트랜잭션이 동시에 실행될 때 다른 트랜잭션에 영향을 주지 않아야 한다.
- Durability (지속성): 트랜잭션이 완료되면 결과는 영구적으로 유지되어야 한다.

## 4.2.11.1 리두 로그 아카이빙
> MySQL 8.0 버전부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙할 수 있는 기능이 추가되었다.
- 데이터 파일이 복사되는 동안 리두 로그 엔트리가 같이 백업되지 않는다면 데이터 백업 파일은 일관된 상태를 유지하지 못한다.
- 데이터 변경이 많으면 리두 로그가 빠르게 증가하고, 복사되지 못한 리두 로그가 덮어쓰여 복사하지 못하고 백업에 실패할 수 있다.
- MySQL 8.0의 리두 로그 아카이빙은 데이터 변경이 많아서 리두 로그가 덮어쓰인다고 해도 백업이 실패하지 않도록 해준다.

## 4.2.11.2 리두 로그 활성화 및 비활성화
- MySQL 서버가 비정상적으로 종료되었을 때 트랜잭션을 복구하기 위해 항상 활성화되어 있다.
- 트랜잭션이 commit 되어도 데이터 파일은 즉시 디스크로 동기화되지는 않은 반면, 리두 로그에는 항상 기록된다.
- ~ MySQL 8.0
    - 수동으로 리두 로그를 비활성화할 수 없다.
- MySQL 8.0 ~
    - 수동으로 리두 로그를 비활성화할 수 있다.
    - 데이터를 복구하거나 대용량 데이터를 한번에 적재할 경우 리두 로그를 비활성화해서 시간을 단축시킨다.
    - ```sql
        ALTER INSTANCE DISABLE INNODB REDO_LOG;
        -- 리두 로그를 비활성화한 후 대량 데이터 적재를 실행

        -- 리두 로그를 활성화한 후 상태를 확인: Innodb_redo_log_enabled = ON
        ALTER INSTANCE ENABLE INNODB REDO_LOG;
        SHOW GLOBAL STATUS LIKE 'Innodb_redo_log_enabled';

        -- 리두 로그를 비활성화한 후 상태를 확인: Innodb_redo_log_enabled = OFF
        ALTER INSTANCE DISABLE INNODB REDO_LOG;
        SHOW GLOBAL STATUS LIKE 'Innodb_redo_log_enabled';
    - 리두 로그를 비활성화하여 데이터 적재 작업을 마쳤다면 다시 활성화하도록 하자.
        - 리두 로그가 비활성화된 상태에서 MySQL 서버가 비정상적으로 종료되면 마지막 체크포인트 이후 시점의 데이터는 복구할 수 없기 때문이다.

# 4.2.12 어댑티브 해시 인덱스
> InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- `innodb_adaptive_hash_index` 시스템 변수를 이용해서 어댑티브 해시 인덱스 기능을 활성화/비활성화할 수 있다.
- InnoDB의 대표적인 인덱스는 B-Tree다.
    - B-Tree 루트 노드를 거쳐서 최종 리프 노드에 도달하면 데이터를 찾을 수 있다.
        - O(logN) 시간이 걸린다.
    - 같은 키 값을 찾는 작업량이 많아진다면 성능저하가 있을 수 있다.
- 자주 읽히는 키 값을 이용해 해시 테이블을 만든다.
- 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 확인한다.
- 가끔 큰 메모리를 사용할 수도 있다.
- 데이터 페이지의 인덱스 키가 해시 인덱스로 만들어져야 하고 불필요한 경우 제거되어야 한다.
- 어댑티브 해시 인덱스가 활성화되면 InnoDB 스토리지 엔진은 키 값이 해시 인덱스 내 존재 유무를 검색을 통해 알게된다.

## 해시 인덱스
- `{인덱스 키 값, 데이터 페이지 주소}` 형식으로 관리된다.
- `인덱스 키 값 = B-Tree 인덱스의 id와 B-Tree 인덱스의 실제 키 값`
    - InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재하므로 키 값에 인덱스id를 포함시킨다.

## 성능 향상에 도움이 되지 않는 경우
- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우 (JOIN 이나 LIKE 패턴 검색)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

## 성능 향상에 도움이 되는 경우
- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우 (디스크 읽기가 많지 않은 경우)
- 동등 조건 검색이 많은 경우 (동등비교 or IN 연산자)
- 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

# 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교
> 결론: MyISAM, MEMORY를 굳이 사용할 장점은 없으며, InnoDB를 사용하는 것이 좋다.
- MySQL 5.5 ~ 8.0
    - InnoDB 스토리지 엔진이 기본 스토리지 엔진
    - MySQL 서버의 시스템 테이블은 여전히 MyISAM 테이블을 사용
    - 전문 검색이나 공간 좌표 검색 기능은 MyISAM 테이블에서만 지원
- MySQL 8.0 ~
    - MySQL 서버의 모든 시스템 테이블이 InnoDB 스토리지 엔진으로 교체
    - 모든 기능을 InnoDB 스토리지 엔진만으로 구현 가능
- ~ MySQL 5.7
    - MEMORY 스토리지 엔진이 내부 임시 테이블의 용도로 사용
        - 가변 길이 타입의 컬럼을 지원하지 않는다는 문제점 존재

# Q&A
- 체인지 버퍼 머지 스레드란?
