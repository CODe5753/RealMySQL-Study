[InnoDB 스토리지 엔진의 특징](#innodb-스토리지-엔진의-특징)

- [4.2.1 Primary key에 의한 클러스터링](#421-primary-key에-의한-클러스터링)
- [4.2.2 외래 키 지원](#422-외래-키-지원)
- [4.2.3 MVCC (Multi Version Concurrency Control)](#423-mvcc-multi-version-concurrency-control)
- [4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)](#424-잠금-없는-일관된-읽기-non-locking-consistent-read)
- [4.2.5 자동 데드락 감지](#425-자동-데드락-감지)
- [4.2.6 자동화된 장애 복구](#426-자동화된-장애-복구)

[4.2.7 InnoDB 버퍼 풀](#427-innodb-버퍼-풀)

[Q&A](#qa)

# InnoDB 스토리지 엔진의 특징
![img](./img/4.9%20InnoDB%20%EA%B5%AC%EC%A1%B0.png)
## 4.2.1 Primary key에 의한 클러스터링
> InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다.
- 프라이머리 키 값 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
- 쿼리의 실행 계획에서 Primary key는 다른 보조 인덱스에 비해 비중이 높게 설정된다.
- InnoDB는 클러스터링 키를 지원한다.
- MyISAM에서는 클러스터링 키를 지원하지 않아서 Primary Key, 세컨더리 인덱스의 구조적 차이가 없다.

## 4.2.2 외래 키 지원
- InnoDB 스토리지 엔진 레벨에서 지원하고, MyISAM, MEMORY 테이블에서는 사용할 수 없다.
- InnoDB에서 부모, 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하다.
    - 변경 시에는 반드시 부모, 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하다.
    - 따라서 잠금이 여러 테이블로 전파되어 데드락이 발생할 때가 많아서 주의해야 한다.
- 수동으로 데이터 조작 시 작업이 실패할 수 있다.
    - `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래키 관계에 대한 체크를 일시적으로 멈출 수 있다.
        - 이렇게 되면 대략 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요 없어서 빠르게 처리할 수 있다.
        - 해당 상태에서는 부모 테이블에 대한 작업 (ON DELETE/UPDATE CASCADE 옵션)을 무시한다.
        - ex) `SET foreign_key_checks=OFF`

## 4.2.3 MVCC (Multi Version Concurrency Control)
> 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능으로 잠금을 사용하지 않는 일관된 읽기를 제공한다.
- InnoDB는 언두 로그로 이 기능을 구현한다.
- Multi Version: 하나의 레코드에 의해 여러 개의 버전이 동시에 관리된다는 의미

```sql
CREATE TABLE member (
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(100) NOT NULL,
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');

COMMIT;
```
![img](./img/4.10%20InnoDB%EC%9D%98%20%EB%B2%84%ED%8D%BC%20%ED%92%80%EA%B3%BC%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%8C%8C%EC%9D%BC%EC%9D%98%20%EC%83%81%ED%83%9C.png)
- member 테이블을 생성하여 데이터를 `insert` 할 시 InnoDB 버퍼 풀에 데이터가 저장된다.
- `commit` 과정을 거친 후에 디스크에 데이터가 저장된다.

```sql
UPDATE member SET m_area='경기' WHERE m_id=12;
```
![img](./img/4.11%20UPDATE%20%ED%9B%84%20InnoDB%20%EB%B2%84%ED%8D%BC%20%ED%92%80%EA%B3%BC%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%8C%8C%EC%9D%BC%20%EB%B0%8F%20%EC%96%B8%EB%91%90%20%EC%98%81%EC%97%AD%EC%9D%98%20%EB%B3%80%ED%99%94.png)
- `update` 시 먼저 InnoDB 버퍼 풀의 변경될 가능성이 있는 데이터가 언두 로그에 복사된다.
- 이후 InnoDB 버퍼 풀의 데이터가 바로 변경된다.
- 만약 `commit` 단계가 진행되지 않은 상태로 `select`로 데이터를 조회한다면
    - 격리 수준이 `READ_UNCOMMITTED`인 경우에는 InnoDB가 갖고있는 데이터를 조회한다.
    - 격리 수준이 `READ_COMMITTED`이거나 그 이상(`REPEATABLE_READ`, `SERIALIZABLE`)인 경우 언두 영역의 데이터를 반환한다.
    - 이러한 과정을 MVCC라고 함
        - 하나의 데이터에 대해 2가지 버전이 유지되고, 필요에 따라 보여질 데이터가 결정되는 구조
        - 언두 로그의 데이터가 많아져 언두 영역이 저장되는 시스템 테이블스페이스의 공간이 많이 늘어나는 상황이 발생할 수 있다.
- `commit` 명령을 실행하면 InnoDB의 데이터가 영구적인 데이터가 된다.
    - commit 시 언두 영역의 데이터가 바로 삭제되지는 않으며, 더 이상 해당 언두 영역을 필요로하는 트랜잭션이 없을 때 삭제된다.
- `rollback` 시 언두 영역에 있는 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 데이터를 모두 삭제한다.

## 4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
> InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 잠금을 걸지 않으므로 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.
- 격리 수준 READ_COMMITTED 이상일 때 순수 SELECT 작업은 다른 트랜잭션 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.
    - 변경 전의 데이터를 읽기 위해 언두 로그를 사용한다.
- 다만 이러한 작업을 위해 언두 로그를 삭제하지 못하고 유지해야하므로 MySQL 서버가 느려지거나 문제가 발생할 때가 있다.
    - 트랜잭션이 시작됐다면 가능한 한 빨리 rollback or commit으로 트랜잭션을 완료하는 것이 좋다.

## 4.2.5 자동 데드락 감지
> InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료한다.
    - 종료할 트랜잭션을 판단하는 기준은 트랜잭션의 언두 로그 양이다.
    - 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 rollback의 대상이 된다.
        - 언두 처리할 내용이 적고, 강제 롤백으로 인한 MySQL 서버 부하도 덜 유발하기 때문
- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 볼 수가 없어서 데드락 감지가 불확실할 수 있다.
    - `innodb_table_locks` 시스템 변수를 활성화하여 InnoDB 스토리지 엔진 내부의 레코드 뿐만 아니라 테이블 레벨의 잠금도 감지할 수 있게 된다.
- 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 갯수가 많아지면 데드락 감지 스레드가 느려진다.
    - 데드락 감지 스레드는 잠금 목록이 저장된 리스트에 잠금을 걸고 데드락 스레드를 찾는다.
    - 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미친다.
    - 더 많은 CPU 자원을 소모하게 된다.
    - MySQL 서버에서 제공하는 `innodb_deadlock_detect` 시스템 변수를 `OFF`로 설정하면 데드락 감지 스레드는 작동하지 않게 된다.
        - 데드락 발생 시 무한정 대기 상태가 된다.
        - `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환한다.

## 4.2.6 자동화된 장애 복구
- InnoDB에 손실이나 장애로부터 데이터를 보호하기 위한 메커니즘이 탑재되어있다.
- 이를 이용하여 MySQL 서버가 시작될 때 복구 작업이 자동으로 진행된다.
- 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고, MySQL 서버는 종료된다.

-> MySQL 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 시작하도록 한다.
- InnoDB의 로그 파일이 손상됐다면 6으로 설정하고 MySQL 서버를 기동한다.
- InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 MySQL 서버를 기동한다.
- 어떤 부분이 문제인지 알 수 없다면 1 ~ 6 범위 내에서 변경하면서 MySQL 서버를 재시작해본다.
- 값이 커질수록 심각한 상황이므로 데이터 손실 가능성은 커지고, 복구 가능성은 작아진다.

### innodb_force_recovery
- MySQL 서버가 기동되고 InnoDB 테이블이 인식된다면 mysqldump를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.
- 값이 0이 아닌 복구모드에서는 SELECT 이외의 쿼리는 수행할 수 없다.
1. SRV_FORCE_IGNORE_CORRUPT
    - InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 MySQL 서버를 시작한다.
    - `Database page corruption on disk or a failed` 메시지가 출력될 때 대부분 해당
    - mysqldump를 이용해 데이터베이스를 다시 구축하는 것이 좋다.
2. SRV_FORCE_NO_BACKGROUND
    - 백그라운드 스레드 중 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다.
    - 트랜잭션이 commit되어 불필요해진 언두 데이터는 InnoDB의 메인 스레드에 의해 주기적으로 삭제된다.
    - InnoDB의 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생할 때 사용한다.
3. SRV_FORCE_NO_TRX_UNDO
    - MySQL 서버 시작 시 커밋되지 않은 트랜잭션의 작업을 rollback하지 않고 그대로 둔다.
    - MySQL 서버가 시작되면 mysqldump를 이용해 데이터를 백업해서 다시 데이터베이스를 구축하는 것이 좋다.
4. SRV_FORCE_NO_IBUF_MERGE
    - MySQL 서버 재시작 시 인서트 버퍼의 손상을 감지하면 InnoDB는 에러를 발생시키고, MySQL 서버는 시작하지 못한다.
    - InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL이 시작되게 한다.
    - 인서트 버퍼는 실제 데이터가 아닌 인덱스에 관련된 부분이므로 테이블을 덤프하고 데이터베이스를 다시 구축하면 데이터의 손실 없이 복구할 수 있다.
5. SRV_FORCE_NO_UNDO_LOG_SCAN
    - InnoDB 엔진이 언두 로그를 무시하고 MySQL을 시작하도록 한다.
    - MySQL 서버가 종료되던 시점에 commit되지 않았던 작업도 모두 commit된 것처럼 처리되므로 실제로 잘못된 데이터가 남을 수도 있다.
    - mysqldump를 이용해 데이터를 백업하고 데이터베이스를 새로 구축해야 한다.
6. SRV_FORCE_NO_LOG_REDO
    - 리두 로그를 모두 무시한 채로 MySQL 서버가 시작된다.
    - commit이 되었다고 해도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이터는 무시된다.
    - 기존 InnoDB의 리두 로그는 모두 삭제하거나 별도의 디렉토리에 백업하고 MySQL 서버를 시작하는 것이 좋다.
    - mysqldump를 이용해 데이터를 백업하고 데이터베이스를 새로 구축하는 것이 좋다.
-> 모두 실패 시 백업을 이용하여 데이터베이스를 다시 구축하도록 한다.

# 4.2.7 InnoDB 버퍼 풀

# Q&A
