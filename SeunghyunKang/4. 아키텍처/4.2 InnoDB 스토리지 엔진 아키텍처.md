> InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다.  
> 이 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

![InnoDB 구조](./../resources/4.9%20InnoDB%20구조.png)

# Primary key에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 Primary Key를 기준으로 클러스터링 되어 저장된다.
  - PK 값의 순서대로 디스크에 저장된다는 뜻
- 모든 Secondary Index는 레코드의 주소 대신 PK의 값을 논리적 주소로 사용
- PK가 클러스터링 Index이기 때문에 PK를 이용한 Range scan은 상당히 빨리 처리될 수 있다.
  - 쿼리 실행 계획에서 PK는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.
- MyISAM에서는 클러스터링 키를 지원하지 않는다.
  - 그래서 MyISAM 테이블에서는 PK와 Secondary Index는 구조적으로 차이가 없다

# 외래 키 지원
외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 
MEMORY 테이블에서는 사용할 수 없다.
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요
- 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요
- 즉, 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의 하는 것이 좋다.
```sql
-- 외래 키 체크 일시 해제
-- global, session 모두 설정 가능한데, 생략하면 현재 세션만 설정 변경함
SET foregin_key_checks=OFF;
```
외래 키 체크를 일시 해제하게 되면, 외래 키 관계의 부모 테이블에 대한 작업(ON DELETE CASCADE와 ON CASCADE 옵션)도 무시하게 됨

# MVCC
> MVCC, Multi Version Concurrency Control

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공하는 것이 목적
- InnoDB는 언두 로그(Undo Log)를 이용해 이 기능을 구현

MVCC의 MV 즉, Multi Version은 **하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미**

## READ_COMMITTED의 데이터 변경
```sql
CREATE TABLE member (
  m_id INT NOT NULL,
  m_name VARCHAR(20) NOT NULL,
  m_area VARCHAR(100) NOT NULL,
  PRIMARY KEY (m_id),
  INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
COMMIT;
```
<img src="../resources/4.10%20InnoDB의%20버퍼%20풀과%20데이터%20파일의%20상태.png" alt="InnoDB의 버퍼 풀과 데이터 파일의 상태" style="zoom:50%;" />

INSERT가 실행되면 위와 같은 상태로 변경된다.
즉, INSERT가 실행되면 INSERT 된 row는 InnoDB 버퍼 풀에 등록된다.

<img src="../resources/4.11%20UPDATE%20후%20InnoDB%20버퍼%20풀과%20데이터%20파일%20및%20언두%20영역의%20변화.png" alt="4.11 UPDATE 후 InnoDB 버퍼 풀과 데이터 파일 및 언두 영역의 변화" style="zoom:50%;" />

```sql
UPDATE member SET m_area='경기' WHERE m_id=12;
```
그리고 UPDATE문이 실행되면 위와 같은 상태로 바뀐다.
UPDATE가 실행되면 **커밋 실행 여부와 관계없이** InnoDB의 버퍼 풀은 새로운 값인 '경기'로 업데이트된다.
그리고 언두 로그엔 바뀌기 이전 값이 기록되는데, PK와 변경된 필드의 데이터만 기록된다.

만약, COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회하면 어디에 있는 데이터를 조회할까?
```sql
SELECT * FROM MEMBER m_id=12;
```
정답은, MySQL 서버의 시스템 변수 transaction_isolation에 설정된 격리 수준에 따라 다르다.
### READ_UNCOMMITED인 경우
> "커밋되기 전이어도 값을 읽겠다!!"

InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환

### READ_COMMITED, REPEATABLE_READ, SERIALIZABLE
> "커밋된 후의 데이터만 읽겠다!!"

아직 커밋되기 전이므로 **언두 영역의 데이터 반환**

**이러한 과정을 DBMS에서는 MVCC라고 표현한다.**

만약, 여기서 롤백을 해버리면 언두 로그는 다시 버퍼 풀로 가고, 언두 로그는 삭제된다.
그리고 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니다.
이 **언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 삭제**된다.

# 잠금 없는 일관된 읽기
> Non-Locking Consistent Read

MVCC와 관련된 내용인데,
InnoDB 스토리지 엔진은 MVCC 기술을 이용해 **잠금을 걸지 않고 읽기 작업을 수행**한다.
격리 수준이 `SERIALIZABLE`이 아닌 `READ_UNCOMMITTED`나 `READ_COMMITED`, `REPEATABLE_READ` 수준인 경우 INSERT와 연결되지 않은 SELECT는 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

다시 기억해야 할 점은, InnoDB에서는 **변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다**는 점이다.

|격리 수준|결과|읽는 위치|
|---|:---:|:---:|
|READ_UNCOMMITTED|경기|버퍼 풀|
|READ_COMMITED|서울|언두 로그|
|REPEATABLE_READ|서울|언두 로그|

간혹 오랜 시간 활성 상태인 트랜잭션으로 서버가 느려지는 문제가 발생하는데,
일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생한다.
따라서, 트랜잭션 시작 후 가능한 빨리 롤백이나 커밋으로 트랜잭션을 완료하는게 좋다.

# 자동 데드락 감지
- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록(Wait-for List)을 그래프 형태로 관리한다.
- 데드락 감지 스레드를 갖고 있다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아 그중 하나를 강제종료 한다.
- 이때 어떤 트랜잭션을 먼저 종료할 것인지를 판단하는 기준은 **트랜잭션의 언두 로그 양**이다.
- **<u>언두로그를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상</u>**이 된다.
  - 롤백을 해도 언두 처리를 해야 할 내용이 적다는 뜻
  - 트랜잭션 강제 롤백으로 인한 서버의 부하도 덜 유발한다는 뜻

## 불확실한 데드락 감지
InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금(LOCK TABLES 명령으로 잠긴 테이블)은 볼 수가 없어 데드락 감지가 불확실 할 수 있다.
- innodb_table_locks 시스템 변수를 활성화
  - InnoDB 스토리지 엔진 내부의 레코드 잠금 감지 가능
  - 테이블 레벨의 잠금까지 감지 가능

"특별한 이유가 없다면 `innodb_table_locks` 시스템 변수를 활성화하자"
![이미 활성화 됨](../resources/innodb_table_locsk.png)

> 출처: https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_table_locks

옵션을 보면 MySQL 8.0 기준으로 default 값이 ON 인 것을 볼 수 있고, 별다른 설정을 안해놨다면 켜져있다.

## 부담 돼 너의 잠금
일반적인 서비스에서 데드락을 찾아내는 작업은 크게 부담되지 않는다.
하지만 **동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다**.

- 데드락 스레드는 잠금 목록을 검사해야 하기 때문에 **잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고** 데드락 스레드를 찾게 된다.
  - 즉, 락 체크를 위한 락을 건다는 뜻
  - 이로 인해 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

### 부담을 해결해보자

해결을 위해 MySQL 서버는 `innodb_deadlock_detect` 시스템 변수를 제공한다.

- `innodb_deadlock_detect`를 OFF로 설정하면 데드락 감지 스레드는 더 이상 작동하지 않는다.
- InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황(데드락)이 발생해도 누군가 중재를 하지 않기 때문에 무한 대기한다.
- 하지만 `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 동일 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메세지를 반환한다.
  - 이는 초 단위로 설정할 수 있다.
  - 정해진 시간 동안 획득하지 못하면 쿼리는 실패하고 에러를 반환한다.
  - default는 50초이며, `innodb_deadlock_detect`를 OFF하고 <u>**50초보다 낮은 시간으로 변경해 사용할 것을 권장**</u>한다.

## TMI. 구글의 대처

구글엔 PK 기반의 조회 및 변경이 아주 높은 빈도로 실행되는 서비스가 많았는데,

매우 많은 트랜잭션을 동시에 실행하므로 데드락 감지 스레드가 상당히 성능을 저하시킨다는 것을 알았다.

MySQL 서버의 소스코드를 변경해 데드락 감지 스레드를 ON/OFF 할 수 있게 했다.

이 기능의 필요성을 인지하고 **오라클에 이 기능을 요청해 MySQL 서버에 추가**된 것이다.

만약 PK 또는 세컨더리 인덱스를 기반으로 매우 높은 동시성 처리를 요구하는 서비스가 있다면 `innodb_deadlock_detect`를 비활성화해서 성능 비교를 해보는 것도 새로운 기회가 될 것이다.



# 자동화된 장애 복구

MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 **InnoDB 스토리지 엔진이 자동으로 복구를 못하는 경우, MySQL 서버는 종료**된다.

이 때는 MySQL 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해 MySQL 서버를 시작해야 한다.

이 설정값은 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 한다.

- InnoDB 로그 파일이 손상됐다면 6으로 설정하고 MySQL 서버를 가동
- InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 MySQL 서버를 기동
- 어떤 부분이 문제인지 알 수 없다면 `innodb_force_recovery` 설정값을 1부터 6까지 변경하면서 MySQL을 재시작
  - `innodb_force_recovery`를 1로 설정 후 MySQL 재시작
  - 재시작되지 않으면 2로 설정해 재시작
- `innodb_force_recovery` 값이 커질수록 심각한 상황이라 데이터 손실 가능성이 커지고 복구 가능성은 적어짐

- MySQL 서버가 가동되고 InnoDB 테이블이 인식된다면?

  1. `mysqldump`를 이용해 데이터를 가능한만큼 백업

  2. 해당 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋음

## 각 숫자 값으로 복구되는 장애 상황

> `innodb_force_recovery`가 0이 아닌 복구 모두에서는 SELECT 이외의 INSERT UPDATE DELETE는 수행할 수 없다.

| innodb_force_recovery | 이름                       | 효과                                                         | 상황                                                         |
| :-------------------: | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|           1           | SRV_FORCE_IGNORE_CORRUPT   | 데이터 파일에서 손상된 페이지를 무시하고 시작                | `Database page corruption on disk or a failed` 메시지 출력될 때 대부분 이 경우에 해당 |
|           2           | SRV_FORCE_NO_BACKGROUND    | 백그라운드 메인 스레드를 시작하지 않음                       | 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생하는 경우 |
|           3           | SRV_FORCE_NO_TRX_UNDO      | 장애 발생 시 **커밋되지 않고 종료된 트랜잭션을 그대로 두는 옵션**인데 쉽게 말해 언두 로그를 사용하지 않는 것임 | 트랜잭션 롤백이 복구를 방해하는 경우                         |
|           4           | SRV_FORCE_NO_IBUF_MERGE    | MySQL 서버에서 인덱스 버퍼 병합을 비활성화                   | Mysql 서버 재시작 시 인서트 버퍼의 손상을 감지하는 경우      |
|           5           | SRV_FORCE_NO_UNDO_LOG_SCAN | 언두 로그를 모두 **<u>무시</u>**<br />서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리됨(롤백한단 말이고 실제로는 잘못된 데이터가 남는다는 뜻) | 백업 작업 시 사용된다고 함                                   |
|           6           | SRV_FORCE_NO_LOG_REDO      | 리두 로그를 모두 무시<br />마지막 체크포인트 시점의 데이터만 남음 | 1.특정 테이블 스페이스의 복구가 불가능한 경우, 복구를 시도하지 않고 나머지 데이터베이스를 복구하는 데 사용<br />2.데이터베이스 복구를 수동으로 진행하거나, 데이터 손실을 감수하고 빠르게 서비스를 재개하려는 경우 |



# InnoDB 버퍼 풀

드디어 나왔다

---
# 궁금증
1. 클러스터링이란 뭘까?
2. 실무에서 JPA 외래 키를 이용한 연관관계 매핑 하는지?
   - 저는 외래 키를 사용했을 때 수정이나 삭제가 용이하지 않아 잘 사용하지 않는 편
3. DBMS란?
4. 체크포인트?
5. "언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 삭제"
   - 즉, 해당 언두로그를 생성한 트랜잭션이 끝났을 때는 즉시 삭제된다는 말인가?
6. 각 격리 수준은 어떻게 다를까?
7. 동시 처리 스레드가 "매우 많아지거나"에서 매우 많아진다는 어떤 기준으로 판단할 수 있을까?