# MySQL 전체 구조
> MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분

![alt](./../resources/4.1%20MySQL%20서버의%20전체%20구조.png)

### MySQL 엔진
  - 요청된 SQL 문장 분석, 최적화 등 DBMS의 두뇌에 해당하는 처리 수행
### 스토리지 엔진
  - 실제 데이터를 디스크에 저장하거나 디스크로부터 데이터를 읽어오는 역할
  - MySQL 서버에서 MySQL 엔진은 하나지만, 스토리지 엔진은 여러개 동시 사용 가능
    ```mysql
      CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
    ```
### 핸들러 API
> 핸들러 API는 C/C++ 파일로 구성되어 있다.

데이터를 쓰거나 읽어야 할때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이런 요청을 핸들러 요청이라 한다.
여기서 사용되는 API를 핸들러 API라고 하며, InnoDB 스토리지 엔진 또한 이 핸들ㄹ API를 이용해 MySQL 엔진과 데이터를 주고받는다.
```mysql
SHOW GLOBAL STATUS LIKE 'Handler%';
```
위 명령어를 통해 얼마나 많은 데이터 작업을 했는지 확인할 수 있다.

# MySQL 스레딩 구조

![alt](../resources/4.2%20MySQL의%20스레딩%20모델.png)
- MySQL 서버는 스레드 기반으로 작동
  - Foreground, Background Thread로 구분

```mysql
SELECT thread_id, name, type, processlist_user, processlist_host
FROM performance_schema.threads ORDER BY type, thread_id;
```
![스레드 테이블](../resources/4.%20threads%20%ED%85%8C%EC%9D%B4%EB%B8%94.png)

## Foregound Thread(Client Thread)
- 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재
- 주로 각 클라이언트가 요청하는 쿼리 문장 처리
- 커넥션을 종료하면 해당 스레드는 Thread cache로 되돌아감
- 이미 Thread cache에 일정 갯수의 스레드가 있다면 스레드를 종료 시킨다.
  - thread_cache_size 시스템 변수로 Thread Cache의 최대 스레드 갯수 설정
- 데이터 버퍼나 캐시로 부터 데이터를 가져옴
- 버퍼나 캐시에 없는 경우엔 직접 디스크 또는 인덱스 파일로부터 읽어옴
### MyISAM
디스크 쓰기 작업도 Foreground Thread가 처리함
### InnoDB
데이터 버퍼나 캐시까지만 Foreground Thread가 처리하고 나머진 Background Thread가 처리

## Background Thread
> MyISAM은 해당 사항 없음

### InnoDB에서의 역할
- Insert Buffer를 병합
- **로그를 디스크로 기록(Log Thread)**
- **InnoDB 버퍼 풀의 데이터를 디스크에 기록(Write Thread)**
- 데이터를 버퍼로 읽어 오기
- 잠금이나 데드락을 모니터링

### 쓰기 쓰레드
- innodb_write_io_threads로 스레드 갯수 설정 가능
- 쓰기 쓰레드는 아주 많은 작업을 백그라운드로 처리
- 일반적인 내장 디스크를 사용할 때는 2~4정도 사용
- DAS나 SAN과 같은 스토리지는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋음

### 쓰기 버퍼링
- 상용 DBMS와 **InnoDB의 쓰기 작업은 지연(버퍼링)되어 처리**된다.
- MyISAM은 읽기/쓰기가 함께 처리됨

# 메모리 할당 및 사용 구조
![메모리 사용 및 할당 구조](./../resources/4.3%20MySQL의%20메모리%20사용%20및%20할당%20구조.png)
- 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분됨
- 글로벌 메모리 영역은 MySQL 서버 시작 시 OS로부터 할당

## 글로벌 메모리 영역
- 메모리 공간 할당 수는 클라이언트 스레드 수와 무관
- 글로벌 영역이 2개라고 해도 모든 스레드가 공유함
- 대표적인 글로벌 메모리 영역
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

## 로컬 메모리 영역
> 세션 메모리 영역과 같은 말

- 클라이언트 스레드가 사용하는 영역
- 클라이언트 스레드별로 독립적으로 할당
- **스레드끼리 절대 공유되지 않음**
- 쿼리의 용도별로 필요할 때만 공간이 할당되고, **필요 하지 않는 경우엔 메모리 공간을 할당조차 하지 않을 수 있음**
  - ex) sort buffer, join buffer
- 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간
  - ex) Connection buffer, result buffer
- 실행하는 순간에만 할당했다가 다시 해제하는 공간
  - ex) sort buffer, join buffer
- 대표적인 로컬 메모리 영역
  - Sort buffer
  - Join Buffer
  - Binary Log Cache
  - Network Buffer

# 플러그인 스토리지 엔진 모델
![플러그인 모델](../resources/4.4%20MySQL%20플러그인%20모델.png)

쉽게 말해서, MySQL 서버에서 사용할 수 있는 확장 기능이다.  
MySQL 서버의 기능을 보완하거나 새로운 기능을 추가할 수 있다.
대표적으로 인증, 암호화, 스토리지 엔진 플러그인 등이 있다.

### 핸들러
- MySQL 엔진이 스토리지 엔진을 조정하기 위해 핸들러를 사용
- 즉, MySQL 엔진이 스토리지 엔진에게 데이터를 읽어 오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 함
- GROUP BY, ORDER BY 등 **복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 `쿼리 실행기`에서 처리**됨

# 컴포넌트
> MySQL 8.0부터 플러그인 아키텍처를 대체하기 위해 지원한다

### 대체하는 이유, 플러그인의 단점
1. 플로그인은 오직 MySQL 서버와 인터페이스 할 수 있고, 플러그인끼리 통신 불가
2. MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 불가)
3. 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

**위와 같은 단점을 보완한 것이 컴포넌트이다.**

# 쿼리 실행 구조
SQL 요청이 들어오면 아래 순서대로 실행된다.  
쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기 -> 스토리지 엔진 -> SQL 결과 반환

### 쿼리 파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리
- 트리 형태의 구조로 만들어냄
- 쿼리 문장의 **기본 문법 오류는 이 과정에서 발견**되고 사용자에게 오류 메세지 전달

### 전처리기
- 파서 트리를 기반으로 문장에 구조적 문제가 있는지 파악
- 각 토큰을 테이블 명, 컬럼 명, 내장 함수와 같은 개체를 매핑해 해당 객체 존재 여부 및 접근 권한 등을 확인함
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러짐

### 옵티마이저
- 쿼리 변환, 비용 최적화, 실행 계획 수립
- 얘도 MySQL의 컴포넌트이다.

### 실행 엔진
옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용했다고 결정한다면
1. 실행 엔진이 핸들러에게 임시 테이블 만들라고 요청
2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김


즉, 실행 엔진은 **만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 수행**

### 핸들러(스토리지 엔진)
- 디스크에 저장/읽기 수행하는 역할
- MyISAM 테이블 조작 시 핸들러가 MyISAM 스토리지 엔진이 됨
- InnoDB 테이블 조작 시 핸들러가 InnoDB 스토리지 엔진이 됨

### 복제(Replication)
뒤에서 배운다고 한다..

### 쿼리 캐시
- SQL 실행 결과를 메모리에 캐시함
- 동일 결과는 테이블을 읽지 않고 즉시 결과를 반환함
- MySQL 8.0 이전엔, 테이블 데이터가 변경되면 변경된 테이블 데이터와 연관된 것들을 모두 삭제해야 해서 심각한 동시 처리 성능 저하를 유발했음
- **MySQL 8.0부터 쿼리 캐시 기능이 제거됨**
- 데이터 변경은 거의 없고 읽기만 하는 서비스에서는 매우 훌륭한 기능

```text
TMI) 8.0 이전엔 조회수와 같은 잦은 변경이 발생하는 경우,
테이블 성능을 고려할 때 쿼리캐시도 성능 고려 대상이었는데
8.0부터 고려할 필요가 없음.
즉, 8.0 이전엔 쿼리캐시 때문에라도 테이블을 분리해야했음
```

### 스레드 풀
> MySQL 서버 엔터프라이즈 에디션은 해당 기능을 제공하지만, 커뮤니티 에디션은 해당 기능을 지원하지 않는다

스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서,  
동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의  
스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적이다.

제한된 수의 스레드만으로 CPU가 처리하도록 적절히 유도한다면 CPU의 프로세서 친화도도 높이고 OS 입창에서는 불필요한 컨텍스트 스위치를 줄여 오버헤드를 낮출 수 있다.

### 트랜잭션 지원 메타데이터
- MySQL 서버는 5.7버전까지 테이블 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램또한 파일 기반으로 관리했다
- 이러한 파일 기반 메타데이터는 생성 및 변경 작업이 트랙잭션을 지원하지 않아, 생성 또는 변경 도중 서버가 비정상적으로 종료되면 데이터가 일관성을 잃는다.
- 이를 "테이블이 깨졌다" 라고 표현한다.
- MySQL 8.0 버전부터 코드 관련 정보를 모두 InnoDB 테이블에 저장하도록 개선됐다.
- 서버가 작동하는데 기본적으로 필요한 테이블들을 "시스템 테이블"이라고 한다
- 대표적으로 사용자 인증과 권한에 관련된 테이블이 있다
- 8.0부터 데이터 딕셔너리와 시스템 테이블이 InnoDB 스토리지 엔진에 저장되도록 개선되면서 이제 스키마 변경이 완전한 성공 또는 완전한 실패로 정리된다.

---
## 궁금증
1. 성능 향상을 위한 키 캐시(MyISAM 스토리지 엔진) 기능
2. InnoDB 버퍼 풀 기능
3. Foreground cache에서 왜 Thread를 캐싱할까?
4. thread_cache_size의 default는 몇일까? 그리고 그 이유는?
5. Foregound Thread에서 데이터 버퍼란?
6. DAS, SAN?
7. "innodb에서는 insert update delete 쿼리로 데이터가 변경되는 경우 **데이터가 디스크의 데이터 파일로 완전히 저장 될 때까지 기다리지 않아도 된다**." 이게 무슨 의미일까?
    - MyISAM에서는 데이터 변경 작업이 즉시 디스크의 데이터 파일에 저장됨
    - InnoDB에서는 데이터 변경 작업이 버퍼에 저장되면 해당 작업이 즉시 완료되고 커밋될 수 있으며, 데이터 파일에 저장되는 작업은 나중에 백그라운드에서 처리됨
8. InnoDB 어댑티브 해시 인덱스?
9. InnoDB 리두 로그 퍼버?
10. 테이블 캐시?
11. Sort나 Join에 왜 버퍼가 따로 필요할까?
12. 실무에서 플러그인 써보셨거나 쓰는 사례 본 적 있으신가요?
13. InnoDB가 여러 방면에서 좋아 보이는데, InnoDB가 아닌 MyISAM을 쓰는 경우도 있을까?
14. 플러그인 상호 의존성이란 무엇일까?
  ```
  예를 들어, MySQL에서는 다음과 같은 플러그인이 있을 수 있습니다.

  플러그인 A: 데이터 암호화를 수행하는 플러그인
  플러그인 B: 로깅을 수행하는 플러그인
  플러그인 C: 플러그인 A와 플러그인 B에서 제공하는 기능을 함께 사용하는 플러그인
  위와 같은 상황에서 플러그인 C는 플러그인 A와 플러그인 B에서 제공하는 기능을 함께 사용해야 합니다. 이 때, 플러그인 A와 플러그인 B는 각각 독립적으로 개발되었기 때문에, 플러그인 C가 초기화될 때 플러그인 A와 플러그인 B의 초기화가 완료되지 않은 상태일 수 있습니다.

  이 경우, 플러그인 C는 플러그인 A와 플러그인 B에서 제공하는 기능을 사용할 수 없거나, 잘못된 동작을 수행할 수 있습니다. 따라서, 플러그인 C에서는 플러그인 A와 플러그인 B의 초기화가 완료된 후에만 제공하는 기능을 사용해야 합니다.

  이와 같은 상황을 방지하기 위해, 플러그인을 개발할 때에는 플러그인 간 상호 의존성을 최소화하는 것이 좋습니다. 가능한 독립적으로 개발하고, 필요한 경우 별도의 플러그인으로 분리하여 사용하는 것이 좋습니다.
  ```
15. RDS나 Aurora를 쓰면 일반적으로 스레드풀 지원이 되지 않는걸까?
