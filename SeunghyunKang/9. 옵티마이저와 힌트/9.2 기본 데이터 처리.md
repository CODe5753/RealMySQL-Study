# 9.2 기본 데이터 처리

결과물은 동일해도 그 결과를 만들어 내는 과정은 천차만별이다.

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

MySQL 옵티마이저는 다음과 같은 조건에서 풀 테이블 스캔을 선택한다.

- 테이블 레코드 건수가 작아서 인덱스를 통해 읽는 것보다 풀테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.

리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예츠갷서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 가져다 두는 것을 의미한다.

즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부image.png터는 읽기 작업을 백그라운드 스레드로 넘긴다.

백그라운드 스레드가 읽기를 넘겨받는 시점부터 한 번에 4 또는 8개의 페이지를 읽으며 그 수를 증가시키고, 최대 64개의 데이터 페이지까지 읽어 버퍼 풀에 저장해 둔다.

포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리되는 것이다.

```mysql
SELECT count(*) FROM employees;
```

위 쿼리를 실행하면 풀 테이블 스캔을 할 것 같지만 실제 실행 계획은 풀 인덱스 스캔을 하게 될 가능성이 높다.  
모든 컬럼 정보가 필요 없기 때문에 인덱스의 컬럼만으로 훨씬 빠른 처리가 되기 때문이다.

```mysql
SELECT * FROM employees;
```

하지만 위와 같은 쿼리는 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔을 한다.


## 9.2.2 병렬 처리

`innodb_parallel_read_threads`라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경할 수 있다.

수를 점점 늘리면 쿼리 실행 시간이 줄어드는 것을 볼 수 있으나, CPU 코어 개수를 넘어가면 더 느려지는 경우도 발생한다.

### 9.2.3 ORDER BY 처리(Using filesort)

||장점|단점|
|---|---|---|
|인덱스 이용|INSERT UPDATE DELETE 실행될 때 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 매우 빠름|부가적인 인덱스 추가/삭제 작업이 필요하므로 느림. 인덱스도 결국 저장되는 데이터니 추가 공간 필요함. 개수가 늘어날수록 버퍼 풀을 위한 메모리가 많이 필요함|
|Filesort 이용|레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름|정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느림|

모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

인덱스를 수행하지 않고 별도 정렬 처리를 했는지 확인하려면 실행 계획의 Extra 컬럼에 Using filesort 메시지 표시로 알 수 있다.

### 9.2.3.1 소트 버퍼

정렬 수행을 위해 별도 메모리 공간을 할당받아 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.

정렬이 필요한 경우에만 할당되고 버퍼 크기는 정렬해야 할 레코드 크기에 따라 가변적으로 증가하지만 최대 공간은 `sort_buffer_size`라는 시스템 변수로 설정할 수 있다.

소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 어떻게될까?
MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠 처리하는데 이 과정에서 임시 저장을 위해 디스크를 사용한다.

소트 버퍼에서 정렬 수행하고 임시로 디스크에 기록하고 레코드를 가져와 다시 정렬하고 반복적으로 디스크에 임시 저장한다.

이 병합 작업을 멀티 머지라고 표현한다.

정렬을 위해 할당하는 **소트 버퍼는 세션 메모리 영역에 해당**한다.
> 즉, 소트 버퍼는 **여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다.** 커넥션이 많을수록, 정렬 작업이 많을수록 소트 버퍼로 소비되는 공간이 커짐을 의미한다.

더 이상 메모리 여유 공간이 없을때 OS의 OOM-Killer가 메모리를 가장 많이 사용하는 프로세스를 강제 종료한다.
메모리를 가장 많이 사용하는 프로세스는 보통 MySQL 서버다.

### 9.2.3.2 정렬 알고리즘

- 싱글 패스: 레코드 전체를 소트 버퍼에 담기
  - sork_key, packed_additional_fields: 정렬 키와 레코드 전체를 가져와 정렬하는 방식, 레코드 컬럼은 가변 사이즈로 메모리 저장
  - sort_key, addtional_fields: 정렬키와 레코드 전체 가녀와 정렬하는 방식이고 각 컬럼은 고정 사이즈 메모리 저장
- 투 패스: 정렬 기준 컬럼만 소트 버퍼에 담기
  - sort_key, rowid


> 싱글패스 대신 투 패스 쓸 때

- 레코드 크기가 max length for sort data 보다 클 때
- blob, text 타입 컬럼이 select 대상에 포함될 때


### 9.2.3.3 정렬 처리 방법

- 인덱스 사용: 표기 X
- 조인에서 드라이빙 테이블만 정렬: Using filesort
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: Using temporary; Using filesort

> 인덱스를 이용한 정렬

- order by 순서대로 생성된 인덱스 있어야 함
- order by에 명시된 컬럼이 제일 먼저 읽는 테이블에 속함
- where절에 첫 번째로 읽는 테이블 컬럼에 대한 조건이 있다면 그 조건과 order by는 같은 인덱스를 사용할 수 있어야 함
- 해시 인덱스나 전문 검색 인덱스는 인덱스 정렬 불가
- 여러 테이블 조인되는 경우엔 Nested loop 방식 조인에서만 사용 가능

> 조인의 드라이빙 테이블만 정렬

제대로 이해를 못했다..

```mysql
select * from employees e, salaries s
where s.emp_no = e.emp_no
and e.emp_no between 100002 and 100010
order by e.last_name;
```

> 임시 테이블을 이용한 정렬

- 2개 이상 테이블을 조인해 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수 있다
  

```mysql
select * from employees e, salaries s
where s.emp_no = e.emp_no
and e.emp_no between 100002 and 100010
order by s.salary;
```

정렬이 수행되기 전에 salaries 테이블을 읽어야 해서 조인된 데이터를 가지고 정렬할 수밖에 없다.

> 스트리밍 방식

서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식

> 버퍼링 방식

order by, group by는 스트리밍 되는 것을 불가능하게 한다.
where 조건에 따라 모든 레코드를 가져오고 정렬하거나 그루핑해서 차례대로 보내야 하기 때문이다.

인덱스를 사용한 정렬 방식만 스트리밍 형태 처리이고 나머진 모두 버퍼링이다.

## 9.2.4 GROUP BY 처리

### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 GROUP BY 컬럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리

### 9.2.4.2 루스 인덱스 스캔을 사용하는 GROUP BY

실행 계획의 Extra 컬럼에 `Using index for group-by`가 표시된다.

```mysql
EXPLAIN
  SELECT emp_no
  FROM salaries
  WHERE from_date='1985-03-01'
  GROUP BY emp_no;
```

이 테이블의 인덱스는 emp_no, from_date로 생성되어 있기에 WHRERE 조건은 인덱스 레인지 스캔 방식으론 이용할 수 없다.

하지만 인덱스 레인지 스캔을 이용했는데 GROUP BY 처리까지 인덱스를 사용했기 때문이다.

> 책 307p 실행 순서 참고

명시된 쿼리 패턴들이 어떻게 사용될지 얘기해보면 좋을 듯 하다.

루스 인덱스 스캔을 사용할 수 없는 경우는 아래와 같다.
MIN, MAX 이외 집합 함수(SUM...)가 사용된 경우

### 9.2.4.3 임시 테이블을 사용하는 GROUP BY

group by 기준 컬럼이 드라이빙 테이블이건 드리븐이건 관계없이 인덱스를 전혀 사용하지 못할 때 이 방식으로 사용된다.

```mysql
EXPLAIN
  SELECT e.last_name, AVG(s.salary)
  FROM employees e, salaries s
  WHERE s.emp_no=e.emp_no
  GROUP BY e.last_name;
```

위 쿼리는 Extra에 `Using temporary`가 표시된다.
임시 테이블이 사용된 것은 employees 테이블을 풀스캔하기 때문이 아니라 인덱스를 전혀 사용할 수 없는 GROUP BY이기 때문이다.

8.0버전 이전엔 group by가 사용된 쿼리는 그루핑되는 컬럼을 기준으로 묵시적 정렬까지 함께 수행했다. (**last_name 컬럼으로 정렬된 결과를 반환**)

8.0부터는 이 같은 묵시적 정렬은 더 이상 실행되지 않게 바뀌었다.

```mysql
CREATE TEMPORARY TABLE ... (
  last_name VARCHAR(16),
  salary INT,
  UNIQUE INDEX ux_lastname (last_name)
);
```

하지만 8이후에도 group by, order by가 함께 사용되면 명시적으로 정렬 작업을 수행한다.

using temporary와 함께 using filesort가 표시된다.

```mysql
EXLAIN
SELECT e.last_name, AVG(s.salary)
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
GROUP BY e.last_name
ORDER BY e.last_name;
```

## 9.2.5 DISTINCT 처리

집합 함수와 같이 DISTINCT가 사용되는 쿼리의 실행 계획에서 DISTINCT 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하다.
하지만 실행 계획의 Extra 컬럼에는 `Using temporary` 메시지가 출력되지 않는다.

### 9.2.5.1 SELECT DISTINCT ...

단순히 SELECT 되는 레코드 중 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태 쿼리 문장을 사용한다.

```mysql
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no;
```

DISTINCT는 레코드를 유니크하게 SELECT 하는거지, 특정 컬럼만 유니크하게 조회하는 것이 아니다.

