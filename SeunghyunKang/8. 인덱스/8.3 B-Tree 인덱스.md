# 8.3 B-Tree 인덱스

B-Tree 인덱스는 가장 일반적으로 사용되고 가장 먼저 도입된 알고리즘이다.

DBMS에서는 주로 B+-Tree 또는 B\*-Tree가 사용된다.

> 여기서 B는 Balance를 의미한다.

## 8.3.1 구조 및 특성

최상위에 하나의 루트 노드가 존재하고 하위에 자식 노드가 붙어 있는 형태다.
트리 구조의 가장 하위에 있는 노드를 리프 노드라 하고, 루트도 리프도 아닌 노드를 브랜치 노드라 한다.

DB에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

![8.4 B-Tree 인덱스 구조](../resources/8.4%20B-Tree%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%EA%B5%AC%EC%A1%B0.png)

인덱스 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.

만약, 레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계해놨다.
따라서, 항상 INSERT 된 순서로 저장되는 것은 아니다.

> InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 PK 순서로 정렬되어 저장된다.

![B-Tree의 리프 노드와 테이블 데이터 레코드 InnoDB](../resources/8.6%20B-Tree의%20리프%20노드와%20테이블%20데이터%20레코드.png)

인덱스에 저장된 pk 값을 이용해 pk index를 한번 더 검색 후, pk index의 리프 페이지에 저장돼 있는 레코드를 읽는다.

즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

테이블 레코드를 저장/변경하는 경우 index 키 추가/삭제가 발생한다. 이것이 어떻게 처리되는지 알아두면 쿼리 성능을 쉽게 예측할 수 있을 것이다.

### 8.3.2.1 인덱스 키 추가

리프 노드가 꽉 차서 더는 저장할 수 없을땐 리프 노드가 분리(split) 돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.

이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려졌다.

InnoDB에서는 INSERT 실행 후 새로운 키 값을 저장할 수도 있고 지연시킬 수도 있다.  
하지만, PK나 유니크 인덱스는 중복 체크가 필요하므로 즉시 B-Tree에 추가/삭제한다.

### 8.3.2.2 인덱스 키 삭제

B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 된다. 이는 계속 방치되거나 재활용된다.
MySQL 5.5 이상의 InnoDB에서는 이 작업도 버퍼링되어 지연처리될 수 있다.

### 8.3.2.3 인덱스 키 변경

인덱스 키 값에 따라 저장될 리프 노드 위치가 결정되므로 B-Tree 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것을 불가능하다.

먼저 키를 삭제하고, 다시 새로운 키 값을 추가하는 형태로 처리한다.
InnoDB에서는 이 모두 체인지 버퍼를 활용해 지연처리 할 수 있다.

### 8.3.2.4 인덱스 키 검색

INSERT UPDATE DELETE 작업을 할 때 인덱스 관리의 추가비용을 감당하며 구축하는 이유는 바로 **빠른 검색을 위해서다.**

인덱스 검색 작업은 B-Tree의 루트-브랜치-리프 노드까지 이동하며 비교 작업을 수행할텐데 이를 `트리 탐색`이라 한다.

B-Tree 인덱스를 이용한 검색은 100% 일치하거나 값의 앞부분만 일치하는 경우에 사용할 수 있다.

> 그래서 like '%abc%' 같은건 풀스캔 일어나는듯

InnoDB에서 지원하는 레코드 잠금이나 갭락은 적절히 사용할 수 있는 인덱스가 없다면 최악의 경우 테이블 락까지 걸 수 있다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.1 인덱스 키 값의 크기

인덱스 `페이지` 크기와 키 값의 크기에 따라 B-Tree 자식 노드 갯수가 정해진다.

인덱스의 크기가 늘어나면 당연히 한 페이지에 저장할 수 있는 인덱스가 줄어든다.
즉, 디스크 I/O가 늘어난다는 뜻이다.

또한, InnoDB 버퍼풀에에 인덱스 캐시해두는 영역의 효율도 떨어진다.

### 8.3.3.2 B-Tree 깊이

B-Tree의 깊이는 상당히 중요하지만 직접 제어할 방법은 없다.

depth 3인 경우 키 값이 16바이트일때, 최대 2억(585*585*585)개 정도의 키 값을 담을 수 있으나, 32바이트로 늘어나면 5천만(372*372*372)개로 줄어든다.

이 깊이는 MySQL에서 디스크 I/O와 직결되는 문제다.

결론은, 키 값은 작을수록 좋다.

### 8.3.3.3 선택도(기수성)

모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.

전체 인덱스가 100, 유니크 값이 10이라면 기수성은 10이다.

이 선택도가 높을수록 검색 대상이 줄기에 그만큼 빨라진다.

### 8.3.3.4 읽어야 하는 레코드의 건수

100만건 레코드 중 50만건 레코드를 읽어야 할 때, 인덱스를 통해 읽는게 나을까 아니면 전체 테이블을 모두 읽는게 나을까?

일반적인 DBMS 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.

즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 테이블 전체를 읽는다.

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

```mysql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.

범위 검색으로 PK를 가져오고, 랜덤 디스크 I/O를 통해 실제 데이터를 가져온다.

1. 인덱스에서 조건을 만족하는 값이 저장된 위치 찾는다 (인덱스 탐색 Index seek)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. (인덱스 스캔 Index scan)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.

※ 여기서 스캔과 탐색의 차이를 기억해두면 좋다.

### 8.3.4.2 인덱스 풀 스캔

인덱스 처음부터 끝까지 모두 읽는 방식이다.

쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용된다.

예를들어, 인덱스는 A, B, C로 만들어져 있으나 실제 검색은 B나 C 컬럼으로 검색하는 경우다.

쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.
만약, 레코드까지 읽어야하면 절대 이 방식으로 처리되지 않는다.

레인지 스캔보다 느리지만, 풀 테이블 스캔보다는 효율적이다.

### 8.3.4.3 루스 인덱스 스캔

느슨하게, 듬성듬성하게 인덱스를 읽는 것을 의미한다.

필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 것이며 일반적으로 GROUP BY나 MAX(), MIN() 함수에 대해 최적화를 할 때 쓰인다.

```mysql
# dept_no, emp_no가 인덱스임

SELECT dept_no, MIN(emp_no)  
FROM dept_emp
WHERE dep_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

dept_no, emp_no는 이미 정렬되어 있으니까 각 dept_no의 첫번째 emp_no만 읽으면 된다.

### 8.3.4.4 인덱스 스킵 스캔

위 예시에서 emp_no에 대한 검색만 하면 인덱스를 다시 생성해야 했다.
8.0부터 옵티마이저가 앞 컬럼을 건너 뛰고 검색을 가능하게 해주는 스킵 스캔 최적화 기능이 도입됐다.

