# 4장. 아키텍처
## 4.1 MySQL 엔진 아키텍처
- MySQL 서버 
  1. MySQL 엔진 : 머리
  2. 스토리지 엔진 : 손/발 
    - 사용자가 스토리지 엔진을 구현해서 MySQL서버에 추가해서 사용 가능 
    - ex) InnoDB스토리지 엔진, MyISAM스토리지 엔진

## 4.1.1 MySQL의 전체 구조
![image](https://user-images.githubusercontent.com/52403454/229286200-c5f5623b-9396-4008-bee1-e5f4c6229448.png)
- 대부분의 프로그래밍 언어를 모두 지원 .표준 드라이버를 제공. 
### 1. MySQL엔진 
- 요정된 SQL문장을 분석/최적화 -> DBMS의 두뇌 
- MySQL엔진당 하나 
- 구성
  - 커넥션 핸들러 : 클라이언트로부터의 접속 및 쿼리 요청 처리
  - SQL파서 / 전처리기
  - 옵티마이저 : 쿼리의 최적화 실행을 위함
<br><br>

### 2. 스토리지 엔진 
- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분 담당
- 하나의 MySQL에 여러개 존재 가능 
- 성능 향상을 위해 여러 기능 내장 
<br><br>

### 3. 핸들러 API
- 핸들러(Handler) 요청 : MySQL엔진이 쿼리 실행기에서 데이터를 read/write할 떄, 각 스토리지 엔진에 read/write요청 
- 핸들러 API : 핸들러 요청 때 사용되는 API
  - 를 통해 얼마나 많은 데이터(레코드)작업이 있었는지 확인 가능 : $ SHOW GLOBAL STATUS LIKE 'Handler%';
<br><br>

### 4. MySQL 스레딩 구조 
![image](https://user-images.githubusercontent.com/52403454/229286582-94bfe872-697c-4e93-8f92-af17f00e3493.png)
- MySQL는 프로세스 기반이 아닌 스레드 기반 동작, 병렬 처리 가능 
  1. 포그라운드 스레드 (사용자 스레드): 실제 사용자의 요청을 처리
    - 최소한 MySQL서버에 접속된 클라이언트 수만큼 존재 
    - 클라이언트가 커넥션 종료하면 담당 스레드 스레드 캐시로 되돌아감. 스레드 캐시에 일정 개수 이상의 스레드가 대기중일 경우 스레드 캐시로 넣지 않고 스레드 종료. ( 스레드 캐시에는 일정 개수의 캐시만 존재)
    - 스레드 캐시 최대 스레드 개수 시스템 변수로 설정 가능 
    - 데이터를 MySQL의 데이터 버퍼/캐시에서 가져오고, miss날 때는 직접 디스크의 데이터나 인덱스 파일로부터 데이터 읽어와서 처리 (❓ miss날 떄 디스크에서 읽어서 버퍼/캐시에 등록?)
      - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리
      - InnoDB는 데이터 버퍼/캐시까지만 포그라운드 처리. 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리 (❓ 버퍼로부터 디스크에 기록...?) 
  2. 백그라운드 프로세스로 구분 : 서버 설정에 따라 가변적 
    - MyISAM은 백그라운드 잘 안씀
    - InnoDB : 여러가지 작업이 백드라운드로 처리 
      - 로그를 디스크로 기록하는 스레드/버터의 데이터를 디스크로 내려쓰는 작업을 하는 쓰기 스레드 중요
    - MySQL 5.5 부터 read/write 스레드 2개 이상 지정 가능 -> 시스템 변수로 설정 
      - InnoDB 
        - read스레드 : 읽기 작업은 주로 클라이언트 스레드 처리 -> read 스레드 많이 설정할 필요 X
        - write스레드 : 아주 많은 작업을 백그라운드로 처리하기 떄무넹 충분한 스레드 필요 
          - 내장 디스크 사용 : 2~4정도
          - DAS, SAN 스토리지 사용 : 디스크 최적 사용할 수 있을만큼 충분한 스레드 설정  

    - write작업은 지연(버퍼링)되어 처리될 수 있지만 read작업은 절대 지연될 수 없다. 
      - 대부분 DBMS + InnoDB : write작업은 버퍼링해서 일괄 처리하는 기능이 탑재  -> 데이터가 디스크에 완전 저장될 때 까지 기다릴 필요 없다. (❓벌크로 처리되면 데이터 반영 시간이 걸린다는 것?) 
      - MyISAM : 사용자 스레드(포그라운드)가 쓰기 작업까지 함께 처리 

<br><br>

### 5. 메모리 할당 및 사용 구조 
![image](https://user-images.githubusercontent.com/52403454/229341823-de4011ab-dbda-4e7c-b254-c8a273bd8e0a.png)
1. 글로벌 메모리 영역
    - MySQL서버가 시작되면서 운영체제로부터 할당된다. 
    - 운영체제 종류에 따라 할당 방법이 다름 -> 복잡
    - 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당. -> 하나 이상의 메모리 공간 할당받을 수 있지만 여전히 클라이언트 스레드 수와 무관.
    - 모든 스레드에게 공유
2. 로컬 메모리 영역 (세션 메모리 영역, 클라이언트 메모리 영역)
    - MySQL서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역 
    - 클라이언트 스레드가 사용하는 메모리 공간, 클라이언트와 MySQL 서버와의 커넥션인 세션 담당
    - 각 클라이엍느 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다. 
    - 적절한 메모리 공간을 설정하는 것이 좋음 (보통 글로벌 메모리 영역 할당보다 크게 신경쓰지 않음) 
    - 각 쿼리 용도별로 필요할 때만 공간이 할당되고, 필요하지 않을 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다.
      - 소트버퍼/조인버퍼 : 쿼리를 실행하는 순간에만 할당했다가 해제 
      - 커넥션버퍼/결과버퍼 : 커넥션이 열려있는 동안 계속 할당된 상태로 남아있는 공간 
<br><br>

### 6.플러그인 스토리지 엔진 모델
- MySQL은 플러그인 모델 구조 -> 스토리지 엔진/ 검색어 파서 등 플러그인 형태로 개발해서 사용 가능 
- 스토리지에 부가적인 기능 추가 가능. 직접 스토리지 엔진 개발 가능 -> 어처피 스토리지엔진은 데이터 읽기/쓰기 작업만 하니, DBMS의 일부 기능만 수행.
![image](https://user-images.githubusercontent.com/52403454/229344183-f60da210-9bd9-4eb1-a50a-a48da94f1db9.png)
  - 데이터 read/write작업은 대부분 1건의 레토드 단위 
  - MySQL as 자동차
    - MySQL 엔진 : 사람
    - 스토리지 엔진 : 자동차 
    - Handler : MySQL엔진이 스토리지 엔진을 조정하기 위해 핸들러. 
      - MySQL엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다. 
- 다른 스토리지 엔진이더라도 MySQL의 처리 내용은 대부분 동일하며 단순히 '데이터 read/write'영역의 차이만 있을 뿐
- Group by, order by등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL엔진의 처리 영역인 '쿼리 실행기'에서 처리 
- 각 하위 작업이 MySQL에서 처리되는지 아니면 스토리지 영영에서 처리되는지 구분할 줄 알아야 한다. 
- MySQL에서 지원하는 스토리지 엔진 
![image](https://user-images.githubusercontent.com/52403454/229344698-19d4b407-f205-4ddd-a404-75fd1f881109.png)
- MySQL 서버에서 제공하던 기능들을 확장하거나 완전히 새로운 기능들을 플로그인을 이용해서 구현 가능 
<br><br>


### 7. 컴포넌트 
- MySQL 8.0부터는 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처 지원 
- 플러그인 단점
  - 각 플러그인은 MySQL서버와 인터페이스 가능. 프러그인들끼리 통신 불가능
  - MySQL의 변수/함수를 직접 호출하기 때문에 non-safe(캡슐화X)
  - 상호 의존 관계를 설정할 수 없어서 초기화 어려움 (ex. A와 B가 MySQL서버를 통해서 상호관계를 맺고 있지만 직접적으로 연결이 되어있지 않음. 그래서 A를 초기화 하면 B까지 영향받지만 직접적으로 연결이 안되어있으니 무작정 초기화가 어려울 듯?) 

<br><br>

### 8. 쿼리 실행 구조 
![image](https://user-images.githubusercontent.com/52403454/229540871-da2f251f-429f-42d9-ab1a-edd68a4fce0e.png)
1. 쿼리 파서 : 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만듬. 쿼리 문장에 **문법 오류 발생** 시 사용자에게 전달
2. 전처리기 : 파서가 만든 파서 트리를 기반으로 쿼리 문장에 **구조적인 문제점**이 있는지 확인. 
3. 옵티마이저 : 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정. 두뇌/회사경영진
4. 실행 엔진 : 손/발/중간관리자
  - 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청으로 입력하는 역할 수행
5. 핸들러 : 실무자, MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할. 스토리지 엔진.

<br><br>

### 9. 쿼리 캐시 
- SQL실행 결과를 메모리에 캐싱하고, 동일한 SQL쿼리가 실행되면 테이블을 읽지 않고 즉시 결과 반환.
- 캐싱후에 데이터가 바뀌면 변경 테이블과 관련된 모든 삭제 -> 동시 처리 성능 저하 
- 여러 문제로 MySQL8.0에서는 쿼리 캐싱 완전 제거 

<br><br>

### 10. 스레드풀 
- MySQL 엔터프라이즈 -> 스레드풀 제공 / 커뮤니티 -> 스레드 풀 제공X
- MySQL의 스레드 풀은 내장돼 있지만, Percona Server의 스레드 풀은 플러그인 형태로 작동 
- 스레드 풀 : 내부적으로 요청을 처리하는 스레드 개수를 줄여서 동시 처리 되는 요청이 많다 하더라도 MySQL서버의 CPU가 제한된 개수의 스레드 처리만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적 
  - 실제 서비스에서 눈에 띄는 성능 향상을 보여주는 경우는 드물다.
  - 스케줄링 과정에서 CPU 시간을 제대로 확보 못하면 쿼리 처리가 더 느려질 수도 있음 -> 제한된 스레드만으로 CPU가 처리하도록 하면 극복 가능
- Percona Server 스레드 풀은 기본적으로 CPU코어 개수만큼 스레드 그룹을 생성
  - 스레드 그룹 개수 변경 가능하지만, 가급적 default사용.
- 스레드 그룹의 모든 스레드가 일을 처리하고 있다면, 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드(Worker Thread)를 추가할 지, 기존 작업 스레드가 처리 완료할 때까지 기다릴지 여부 판단.
  - 스레드 풀 타이머는 thread_poll_stall_limit 밀리초만큼 작업 스레드가 작업을 끝내지 못한다면 새로운 스레드 생성해서 스레드 그룹에 추가 
    - 스레드 그룹의 스레드 개수는 thread_pool_max_thread 넘길 수 없음 
  - 스레드 그룹의 스레드들은 처리 중에 새로운 쿼리 요청이 오더라도 스레드 풀은 thread_pool_stall_limit시간동안 기다려야 새 요청 처리 가능 
    - 응답시간이 예민해야 한다면  thread_pool_stall_limit 적게 가져가야함. 그렇다고 0안됨 -> 0할거면 스레드 풀 사용 안하는게 좋음
- Percona Server 
  - MySQL을 fork떠서 만든 오픈 소스, InnoDB의 향상된 엔진인 XtraDB 내장 
  - 선순위 큐, 후순위 큐를 이용해서 특정 트랜잭션이나 쿼리를 우선적으로 처리 가능하도록 설계   
<br><br>

### 11. 트렌잭션 메타데이터
- 메타데이터/데이터 딕셔너리 : DB서버에서 테이블의 구조정보와 스토어드 프로그램 등의 정보 
- 5.7버전까지는 테이블 구조를 FRM파일에 저장하고 일부 스토어드 프로그램 또는 파일 기반으로 관리 -> 메타데이터 생성작업이 트래잭션을 지원하지 않음 
- 8.0 버전 : 테이블의 구조 정보다 스토어드 프로그램의 코드 관련 정보를 InnoDB의 테이블에 저장하도록 개선 -> 트랜잭션 지원
  - 시스템 테이블 : MySQL이 작동하는데 기본적으로 필요한 테이블. ex)사용자인증/권한
  - 시스템 테이블 + 메타데이터 다 MySQL DB에 mysql.ibd라는 이름으로 저장
- 테이블들 사용자에게 보여주진 않음 
- MyISAM이나 csv같은 스토리지 엔진은 저장 곤간 따로 필요 
  - MySQL은 InnoDB외의 스토리지 엔진을 위해 SDI파일을 사용. -> InnoDB테이블들의 구조도 SDI로 변환가능 
