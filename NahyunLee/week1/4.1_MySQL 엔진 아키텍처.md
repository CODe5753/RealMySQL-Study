# 아키텍처
## 4.1 MySQL 엔진 아키텍처
- MySQL 서버 
  1. MySQL 엔진 : 머리
  2. 스토리지 엔진 : 손/발 
    - 사용자가 스토리지 엔진을 구현해서 MySQL서버에 추가해서 사용 가능 
    - ex) InnoDB스토리지 엔진, MyISAM스토리지 엔진

## 4.1.1 MySQL의 전체 구조
![image](https://user-images.githubusercontent.com/52403454/229286200-c5f5623b-9396-4008-bee1-e5f4c6229448.png)
- 대부분의 프로그래밍 언어를 모두 지원 .표준 드라이버를 제공. 
1. MySQL엔진 
- 요정된 SQL문장을 분석/최적화 -> DBMS의 두뇌 
- MySQL엔진당 하나 
- 구성
  - 커넥션 핸들러 : 클라이언트로부터의 접속 및 쿼리 요청 처리
  - SQL파서 / 전처리기
  - 옵티마이저 : 쿼리의 최적화 실행을 위함
<br>

2. 스토리지 엔진 
- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분 담당
- 하나의 MySQL에 여러개 존재 가능 
- 성능 향상을 위해 여러 기능 내장 

3. 핸들러 API
- 핸들러(Handler) 요청 : MySQL엔진이 쿼리 실행기에서 데이터를 read/write할 떄, 각 스토리지 엔진에 read/write요청 
- 핸들러 API : 핸들러 요청 때 사용되는 API
  - 를 통해 얼마나 많은 데이터(레코드)작업이 있었는지 확인 가능 : $ SHOW GLOBAL STATUS LIKE 'Handler%';

4. MySQL 스레딩 구조 
![image](https://user-images.githubusercontent.com/52403454/229286582-94bfe872-697c-4e93-8f92-af17f00e3493.png)
- MySQL는 프로세스 기반이 아닌 스레드 기반 동작, 병렬 처리 가능 
  1. 포그라운드 스레드 (사용자 스레드): 실제 사용자의 요청을 처리
    - 최소한 MySQL서버에 접속된 클라이언트 수만큼 존재 
    - 클라이언트가 커넥션 종료하면 담당 스레드 스레드 캐시로 되돌아감. 스레드 캐시에 일정 개수 이상의 스레드가 대기중일 경우 스레드 캐시로 넣지 않고 스레드 종료. ( 스레드 캐시에는 일정 개수의 캐시만 존재)
    - 스레드 캐시 최대 스레드 개수 시스템 변수로 설정 가능 
    - 데이터를 MySQL의 데이터 버퍼/캐시에서 가져오고, miss날 때는 직접 디스크의 데이터나 인덱스 파일로부터 데이터 읽어와서 처리 (❓ miss날 떄 디스크에서 읽어서 버퍼/캐시에 등록?)
      - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리
      - InnoDB는 데이터 버퍼/캐시까지만 포그라운드 처리. 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리 (❓ 버퍼러부터 디스크에 기록...?) 
  2. 백그라운드 프로세스로 구분 : 서버 설정에 따라 가변적 
    - MyISAM은 백그라운드 잘 안씀
    - InnoDB : 여러가지 작업이 백드라운드로 처리 
      - 로그를 디스크로 기록하는 스레드/버터의 데이터를 디스크로 내려쓰는 작업을 하는 쓰기 스레드 중요
    - MySQL 5.5 부터 read/write 스레드 2개 이상 지정 가능 -> 시스템 변수로 설정 
      - InnoDB 
        - read스레드 : 읽기 작업은 주로 클라이언트 스레드 처리 -> read 스레드 많이 설정할 필요 X
        - write스레드 : 아주 많은 작업을 백그라운드로 처리하기 떄무넹 충분한 스레드 필요 
          - 내장 디스크 사용 : 2~4정도
          - DAS, SAN 스토리지 사용 : 디스크 최적 사용할 수 있을만큼 충분한 스레드 설정  

    - write작업은 지연(버퍼링)되어 처리될 수 있지만 read작업은 절대 지연될 수 없다. 
      - 대부분 DBMS + InnoDB : write작업은 버퍼링해서 일괄 처리하는 기능이 탑재  -> 데이터가 디스크에 완전 저장될 때 까지 기다릴 필요 없다. (❓벌크로 처리되면 데이터 반영 시간이 걸린다는 것?) 
      - MyISAM : 사용자 스레드(포그라운드)가 쓰기 작업까지 함께 처리 
